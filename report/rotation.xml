<?xml version="1.0" encoding="ISO-8859-1"?>
<?xml-stylesheet href="pawndoc.xsl" type="text/xsl"?>
<doc source="rotation.inc">
	<assembly>
		<name>rotation.inc</name>
	</assembly>

	<!-- general -->
	<general>
		<summary>  Allows conversion between different rotations  </summary>  <section>Contributer</section>  <ul>  <li>Nero_3D</li>  </ul>  <section>History</section>  <ul>  <li>  <subsection>2.0 (16.03.2019) - incompatible with version 1.x</subsection>  <ul>  <li>All functions rewritten with arrays instead of multiple variables</li>  <li>Documentation added and report files generated</li>  <li>Additional function added</li>  </ul>  </li>  <li>  <subsection>1.2 (11.08.2017)</subsection>  <ul>  <li>GetVehicleObjectPositionWorld and GetVehicleObjectPositionWorld added</li>  </ul>  </li>  <li>  <subsection>1.1 (07.01.2017)</subsection>  <ul>  <li>euler_default renamed to euler_samp</li>  <li>Translation function added for Rotation Matrix</li>  <li>Additional translate parameter 'oT' in MatrixRotate</li>  </ul>  </li>  <li>  <subsection>1.0 (14.08.2016)</subsection>  <ul>  <li>Release</li>  </ul>  </li>  </ul>  <section>Reference</section>  <ul>  <li><a target="_blank" href="https://en.wikipedia.org/wiki/Euler_angles#Rotation_matrix"/></li>  <li><a target="_blank" href="https://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation"/></li>  <li><a target="_blank" href="https://en.wikipedia.org/wiki/Axis%E2%80%93angle_representation"/></li>  <li><a target="_blank" href="http://www.euclideanspace.com/maths/geometry/rotations/index.htm"/></li>  <li><a target="_blank" href="https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles"/></li>  </ul> 
	</general>

	<members>

		<!-- enumerations -->
		<member name="T:E_AANGLE" value="4">
			<tagname value="E_AANGLE"/>
			<member name="C:E_AANGLE_ANGLE" value="0">
				<tagname value="Float"/>
			</member>
			<member name="C:E_AANGLE_X" value="1">
				<tagname value="Float"/>
			</member>
			<member name="C:E_AANGLE_Y" value="2">
				<tagname value="Float"/>
			</member>
			<member name="C:E_AANGLE_Z" value="3">
				<tagname value="Float"/>
			</member>
			<summary>Axis angle enum (angle, x, y, z)</summary> <export>aangle</export>
		</member>
		<member name="T:E_EULER" value="3">
			<tagname value="E_EULER"/>
			<member name="C:E_EULER_ALPHA" value="0">
				<tagname value="Float"/>
			</member>
			<member name="C:E_EULER_BETA" value="1">
				<tagname value="Float"/>
			</member>
			<member name="C:E_EULER_GAMMA" value="2">
				<tagname value="Float"/>
			</member>
			<summary>Euler angle enum (alpha, beta, gamma)</summary> <export>euler</export>
		</member>
		<member name="T:E_QUAT" value="4">
			<tagname value="E_QUAT"/>
			<member name="C:E_QUAT_W" value="0">
				<tagname value="Float"/>
			</member>
			<member name="C:E_QUAT_X" value="1">
				<tagname value="Float"/>
			</member>
			<member name="C:E_QUAT_Y" value="2">
				<tagname value="Float"/>
			</member>
			<member name="C:E_QUAT_Z" value="3">
				<tagname value="Float"/>
			</member>
			<referrer name="ConvertAxisAngleToEuler"/>
			<referrer name="ConvertEulerToEuler"/>
			<referrer name="ConvertEulerToAxisAngle"/>
			<summary>Quaternion enum (w, x, y, z)</summary> <export>quat</export>
		</member>
		<member name="T:E_RMATRIX" value="9">
			<tagname value="E_RMATRIX"/>
			<member name="C:E_RMATRIX_00" value="0">
				<tagname value="Float"/>
			</member>
			<member name="C:E_RMATRIX_01" value="1">
				<tagname value="Float"/>
			</member>
			<member name="C:E_RMATRIX_02" value="2">
				<tagname value="Float"/>
			</member>
			<member name="C:E_RMATRIX_10" value="3">
				<tagname value="Float"/>
			</member>
			<member name="C:E_RMATRIX_11" value="4">
				<tagname value="Float"/>
			</member>
			<member name="C:E_RMATRIX_12" value="5">
				<tagname value="Float"/>
			</member>
			<member name="C:E_RMATRIX_20" value="6">
				<tagname value="Float"/>
			</member>
			<member name="C:E_RMATRIX_21" value="7">
				<tagname value="Float"/>
			</member>
			<member name="C:E_RMATRIX_22" value="8">
				<tagname value="Float"/>
			</member>
			<referrer name="NormalizeMatrix"/>
			<summary>Rotation matrix enum (3 rows, 4 coloums)</summary> <export>rmatrix</export>
		</member>
		<member name="T:E_ROTATION" value="10">
			<tagname value="E_ROTATION"/>
			<member name="C:E_ROTATION_TYPE" value="0">
				<tagname value="rotationtype"/>
			</member>
			<member name="C:E_ROTATION_DATA" value="1">
				<size value="9"/>
			</member>
			<referrer name="GetRotation"/>
			<summary>Rotation array</summary> <export/>
		</member>
		<member name="T:rotationtype" value="20">
			<tagname value="rotationtype"/>
			<member name="C:rtype_axis_angle" value="0">
			</member>
			<member name="C:rtype_euler_xzx" value="1">
			</member>
			<member name="C:rtype_euler_xyx" value="2">
			</member>
			<member name="C:rtype_euler_yxy" value="3">
			</member>
			<member name="C:rtype_euler_yzy" value="4">
			</member>
			<member name="C:rtype_euler_zyz" value="5">
			</member>
			<member name="C:rtype_euler_zxz" value="6">
			</member>
			<member name="C:rtype_euler_xzy" value="7">
			</member>
			<member name="C:rtype_euler_xyz" value="8">
			</member>
			<member name="C:rtype_euler_re_xyz" value="8">
			</member>
			<member name="C:rtype_euler_yxz" value="9">
			</member>
			<member name="C:rtype_euler_yzx" value="10">
			</member>
			<member name="C:rtype_euler_zyx" value="11">
			</member>
			<member name="C:rtype_euler_zxy" value="12">
			</member>
			<member name="C:rtype_euler_re_xzy" value="13">
			</member>
			<member name="C:rtype_euler_re_yxz" value="14">
			</member>
			<member name="C:rtype_euler_re_yzx" value="15">
			</member>
			<member name="C:rtype_euler_re_zyx" value="16">
			</member>
			<member name="C:rtype_euler_re_zxy" value="17">
			</member>
			<member name="C:rtype_euler_samp" value="17">
			</member>
			<member name="C:rtype_quaternion" value="18">
			</member>
			<member name="C:rtype_rotation_matrix" value="19">
			</member>
			<summary>All supported rotation types</summary> <export/>
		</member>

		<!-- constants -->
		<member name="C:EOS" value="0">
			<referrer name="strcopy"/>
		</member>
		<member name="C:cellmax" value="2147483647">
			<referrer name="operator!(Float:)"/>
		</member>
		<member name="C:cellmin" value="-2147483648">
			<referrer name="operator-(Float:)"/>
		</member>
		<member name="C:false" value="0">
			<tagname value="bool"/>
		</member>
		<member name="C:true" value="1">
			<tagname value="bool"/>
		</member>

		<!-- variables -->
		<member name="F:__date">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__rotationtype">
		</member>
		<member name="F:__time">
		</member>
		<member name="F:m100">
			<tagname value="Float"/>
			<referrer name="CombineMatrix"/>
			<referrer name="GetMatrixFromRotation"/>
			<referrer name="RotateMatrix"/>
			<referrer name="ReverseMatrix"/>
		</member>
		<member name="F:m101">
			<tagname value="Float"/>
			<referrer name="CombineMatrix"/>
			<referrer name="GetMatrixFromRotation"/>
			<referrer name="RotateMatrix"/>
			<referrer name="ReverseMatrix"/>
		</member>
		<member name="F:m102">
			<tagname value="Float"/>
			<referrer name="CombineMatrix"/>
			<referrer name="GetMatrixFromRotation"/>
			<referrer name="RotateMatrix"/>
			<referrer name="ReverseMatrix"/>
		</member>
		<member name="F:m110">
			<tagname value="Float"/>
			<referrer name="CombineMatrix"/>
			<referrer name="GetMatrixFromRotation"/>
			<referrer name="RotateMatrix"/>
			<referrer name="ReverseMatrix"/>
		</member>
		<member name="F:m111">
			<tagname value="Float"/>
			<referrer name="CombineMatrix"/>
			<referrer name="GetMatrixFromRotation"/>
			<referrer name="RotateMatrix"/>
			<referrer name="ReverseMatrix"/>
		</member>
		<member name="F:m112">
			<tagname value="Float"/>
			<referrer name="CombineMatrix"/>
			<referrer name="GetMatrixFromRotation"/>
			<referrer name="RotateMatrix"/>
			<referrer name="ReverseMatrix"/>
		</member>
		<member name="F:m120">
			<tagname value="Float"/>
			<referrer name="CombineMatrix"/>
			<referrer name="GetMatrixFromRotation"/>
			<referrer name="RotateMatrix"/>
			<referrer name="ReverseMatrix"/>
		</member>
		<member name="F:m121">
			<tagname value="Float"/>
			<referrer name="CombineMatrix"/>
			<referrer name="GetMatrixFromRotation"/>
			<referrer name="RotateMatrix"/>
			<referrer name="ReverseMatrix"/>
		</member>
		<member name="F:m122">
			<tagname value="Float"/>
			<referrer name="CombineMatrix"/>
			<referrer name="GetMatrixFromRotation"/>
			<referrer name="RotateMatrix"/>
			<referrer name="ReverseMatrix"/>
		</member>
		<member name="F:m200">
			<tagname value="Float"/>
			<referrer name="CombineMatrix"/>
		</member>
		<member name="F:m201">
			<tagname value="Float"/>
			<referrer name="CombineMatrix"/>
		</member>
		<member name="F:m202">
			<tagname value="Float"/>
			<referrer name="CombineMatrix"/>
		</member>
		<member name="F:m210">
			<tagname value="Float"/>
			<referrer name="CombineMatrix"/>
		</member>
		<member name="F:m211">
			<tagname value="Float"/>
			<referrer name="CombineMatrix"/>
		</member>
		<member name="F:m212">
			<tagname value="Float"/>
			<referrer name="CombineMatrix"/>
		</member>
		<member name="F:m220">
			<tagname value="Float"/>
			<referrer name="CombineMatrix"/>
		</member>
		<member name="F:m221">
			<tagname value="Float"/>
			<referrer name="CombineMatrix"/>
		</member>
		<member name="F:m222">
			<tagname value="Float"/>
			<referrer name="CombineMatrix"/>
		</member>
		<member name="F:w1">
			<tagname value="Float"/>
			<referrer name="CombineQuat"/>
			<referrer name="RotateQuat"/>
		</member>
		<member name="F:w2">
			<tagname value="Float"/>
			<referrer name="CombineQuat"/>
		</member>
		<member name="F:x1">
			<tagname value="Float"/>
			<referrer name="CombineQuat"/>
			<referrer name="RotateQuat"/>
		</member>
		<member name="F:x2">
			<tagname value="Float"/>
			<referrer name="CombineQuat"/>
		</member>
		<member name="F:y1">
			<tagname value="Float"/>
			<referrer name="CombineQuat"/>
			<referrer name="RotateQuat"/>
		</member>
		<member name="F:y2">
			<tagname value="Float"/>
			<referrer name="CombineQuat"/>
		</member>
		<member name="F:z1">
			<tagname value="Float"/>
			<referrer name="CombineQuat"/>
			<referrer name="RotateQuat"/>
		</member>
		<member name="F:z2">
			<tagname value="Float"/>
			<referrer name="CombineQuat"/>
		</member>

		<!-- functions -->
		<member name="M:operator!(Float:)" syntax="operator!(Float:)(oper)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<dependency name="cellmax"/>
			<param name="oper">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator%(_:,Float:)" syntax="operator%(_:,Float:)(oper1, oper2)">
			<stacksize value="1"/>
			<param name="oper1">
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator%(Float:,_:)" syntax="operator%(Float:,_:)(oper1, oper2)">
			<stacksize value="1"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
			</param>
		</member>
		<member name="M:operator%(Float:,Float:)" syntax="operator%(Float:,Float:)(oper1, oper2)">
			<stacksize value="1"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator!=(Float:,_:)" syntax="operator!=(Float:,_:)(oper1, oper2)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<dependency name="float"/>
			<dependency name="floatcmp"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
			</param>
		</member>
		<member name="M:operator!=(Float:,Float:)" syntax="operator!=(Float:,Float:)(oper1, oper2)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<referrer name="NormalizeMatrix"/>
			<dependency name="floatcmp"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator-(_:,Float:)" syntax="operator-(_:,Float:)(oper1, oper2)">
			<tagname value="Float"/>
			<stacksize value="4"/>
			<dependency name="float"/>
			<dependency name="floatsub"/>
			<param name="oper1">
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator-(Float:,_:)" syntax="operator-(Float:,_:)(oper1, oper2)">
			<tagname value="Float"/>
			<stacksize value="4"/>
			<dependency name="float"/>
			<dependency name="floatsub"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
			</param>
		</member>
		<member name="M:operator+(Float:,_:)" syntax="operator+(Float:,_:)(oper1, oper2)">
			<tagname value="Float"/>
			<stacksize value="4"/>
			<dependency name="float"/>
			<dependency name="floatadd"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
			</param>
		</member>
		<member name="M:operator/(_:,Float:)" syntax="operator/(_:,Float:)(oper1, oper2)">
			<tagname value="Float"/>
			<stacksize value="4"/>
			<dependency name="float"/>
			<dependency name="floatdiv"/>
			<param name="oper1">
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator/(Float:,_:)" syntax="operator/(Float:,_:)(oper1, oper2)">
			<tagname value="Float"/>
			<stacksize value="4"/>
			<dependency name="float"/>
			<dependency name="floatdiv"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
			</param>
		</member>
		<member name="M:operator*(Float:,_:)" syntax="operator*(Float:,_:)(oper1, oper2)">
			<tagname value="Float"/>
			<stacksize value="4"/>
			<dependency name="float"/>
			<dependency name="floatmul"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
			</param>
		</member>
		<member name="M:operator++(Float:)" syntax="operator++(Float:)(oper)">
			<tagname value="Float"/>
			<stacksize value="1"/>
			<dependency name="operator+(Float:,Float:)"/>
			<param name="oper">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator-(Float:)" syntax="operator-(Float:)(oper)">
			<tagname value="Float"/>
			<stacksize value="1"/>
			<referrer name="NormalizeMatrix"/>
			<referrer name="ConvertEulerToMatrix"/>
			<referrer name="ConvertEulerToQuat"/>
			<referrer name="ConvertQuatToEuler"/>
			<referrer name="ConvertMatrixToEuler"/>
			<referrer name="ReverseEuler"/>
			<referrer name="ConvertQuatToAxisAngle"/>
			<dependency name="cellmin"/>
			<param name="oper">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator--(Float:)" syntax="operator--(Float:)(oper)">
			<tagname value="Float"/>
			<stacksize value="1"/>
			<dependency name="operator-(Float:,Float:)"/>
			<param name="oper">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator-(Float:,Float:)" syntax="operator-(Float:,Float:)(oper1, oper2)">
			<tagname value="Float"/>
			<attribute name="native"/>
			<referrer name="operator--(Float:)"/>
			<referrer name="ConvertAxisAngleToMatrix"/>
			<referrer name="ConvertEulerToMatrix"/>
			<referrer name="ConvertQuatToMatrix"/>
			<referrer name="RotateMatrix"/>
			<referrer name="ConvertEulerToQuat"/>
			<referrer name="ConvertMatrixToQuat"/>
			<referrer name="CombineQuat"/>
			<referrer name="RotateQuat"/>
			<referrer name="ConvertQuatToEuler"/>
			<referrer name="ConvertMatrixToAxisAngle"/>
			<referrer name="RotateAxisAngle"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator+(Float:,Float:)" syntax="operator+(Float:,Float:)(oper1, oper2)">
			<tagname value="Float"/>
			<attribute name="native"/>
			<referrer name="operator++(Float:)"/>
			<referrer name="ConvertAxisAngleToMatrix"/>
			<referrer name="ConvertEulerToMatrix"/>
			<referrer name="ConvertQuatToMatrix"/>
			<referrer name="CombineMatrix"/>
			<referrer name="RotateMatrix"/>
			<referrer name="ConvertEulerToQuat"/>
			<referrer name="ConvertMatrixToQuat"/>
			<referrer name="CombineQuat"/>
			<referrer name="RotateQuat"/>
			<referrer name="ConvertQuatToEuler"/>
			<referrer name="ConvertMatrixToAxisAngle"/>
			<referrer name="RotateAxisAngle"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator/(Float:,Float:)" syntax="operator/(Float:,Float:)(oper1, oper2)">
			<tagname value="Float"/>
			<attribute name="native"/>
			<referrer name="NormalizeMatrix"/>
			<referrer name="NormalizeQuat"/>
			<referrer name="ConvertAxisAngleToQuat"/>
			<referrer name="ConvertMatrixToQuat"/>
			<referrer name="NormalizeAxisAngle"/>
			<referrer name="ConvertQuatToAxisAngle"/>
			<referrer name="ConvertMatrixToAxisAngle"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator*(Float:,Float:)" syntax="operator*(Float:,Float:)(oper1, oper2)">
			<tagname value="Float"/>
			<attribute name="native"/>
			<referrer name="ConvertAxisAngleToMatrix"/>
			<referrer name="ConvertEulerToMatrix"/>
			<referrer name="ConvertQuatToMatrix"/>
			<referrer name="CombineMatrix"/>
			<referrer name="RotateMatrix"/>
			<referrer name="ConvertAxisAngleToQuat"/>
			<referrer name="ConvertEulerToQuat"/>
			<referrer name="ConvertMatrixToQuat"/>
			<referrer name="CombineQuat"/>
			<referrer name="RotateQuat"/>
			<referrer name="ReverseQuat"/>
			<referrer name="ConvertQuatToEuler"/>
			<referrer name="ConvertQuatToAxisAngle"/>
			<referrer name="RotateAxisAngle"/>
			<referrer name="ReverseAxisAngle"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator==(Float:,Float:)" syntax="operator==(Float:,Float:)(oper1, oper2)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<referrer name="ConvertAxisAngleToQuat"/>
			<referrer name="ConvertQuatToAxisAngle"/>
			<dependency name="floatcmp"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator==(Float:,_:)" syntax="operator==(Float:,_:)(oper1, oper2)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<dependency name="float"/>
			<dependency name="floatcmp"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
			</param>
		</member>
		<member name="M:operator&gt;(Float:,Float:)" syntax="operator&gt;(Float:,Float:)(oper1, oper2)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<referrer name="ConvertMatrixToQuat"/>
			<referrer name="ConvertQuatToEuler"/>
			<referrer name="ConvertMatrixToEuler"/>
			<dependency name="floatcmp"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator&gt;(Float:,_:)" syntax="operator&gt;(Float:,_:)(oper1, oper2)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<dependency name="float"/>
			<dependency name="floatcmp"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
			</param>
		</member>
		<member name="M:operator&gt;(_:,Float:)" syntax="operator&gt;(_:,Float:)(oper1, oper2)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<dependency name="float"/>
			<dependency name="floatcmp"/>
			<param name="oper1">
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator&gt;=(Float:,Float:)" syntax="operator&gt;=(Float:,Float:)(oper1, oper2)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<dependency name="floatcmp"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator&gt;=(Float:,_:)" syntax="operator&gt;=(Float:,_:)(oper1, oper2)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<dependency name="float"/>
			<dependency name="floatcmp"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
			</param>
		</member>
		<member name="M:operator&gt;=(_:,Float:)" syntax="operator&gt;=(_:,Float:)(oper1, oper2)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<dependency name="float"/>
			<dependency name="floatcmp"/>
			<param name="oper1">
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator&lt;(Float:,Float:)" syntax="operator&lt;(Float:,Float:)(oper1, oper2)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<referrer name="ConvertQuatToEuler"/>
			<referrer name="ConvertMatrixToEuler"/>
			<dependency name="floatcmp"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator&lt;(Float:,_:)" syntax="operator&lt;(Float:,_:)(oper1, oper2)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<dependency name="float"/>
			<dependency name="floatcmp"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
			</param>
		</member>
		<member name="M:operator&lt;(_:,Float:)" syntax="operator&lt;(_:,Float:)(oper1, oper2)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<dependency name="float"/>
			<dependency name="floatcmp"/>
			<param name="oper1">
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator&lt;=(Float:,Float:)" syntax="operator&lt;=(Float:,Float:)(oper1, oper2)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<dependency name="floatcmp"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator&lt;=(Float:,_:)" syntax="operator&lt;=(Float:,_:)(oper1, oper2)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<dependency name="float"/>
			<dependency name="floatcmp"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
			</param>
		</member>
		<member name="M:operator&lt;=(_:,Float:)" syntax="operator&lt;=(_:,Float:)(oper1, oper2)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<dependency name="float"/>
			<dependency name="floatcmp"/>
			<param name="oper1">
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:@receivepacket" syntax="@receivepacket(packet[], size, source[])">
			<attribute name="public"/>
			<stacksize value="1"/>
			<param name="packet">
				<paraminfo> [] </paraminfo>
				Contains the packet that was received.
			</param>
			<param name="size">
				Contains the number of <b>bytes</b> (not cells) that are in the packet
			</param>
			<param name="source">
				<paraminfo> [] </paraminfo>
				Contains the IP address and the port number of the sender of this packet.
			</param>
			<summary>A packed was received.</summary>    <seealso name="@receivestring"/> <seealso name="sendpacket"/> <remarks>You must call this function before receiving the first packet. In other words, you should set up a port in main.</remarks> <remarks>If no port number has been explicitily chosen, the module will listen at port <c><b>9930</b></c>.</remarks> <remarks>This function does not work in the current SA:MP version!</remarks> <returns>The return value of this function is currently ignored.</returns>
		</member>
		<member name="M:@receivestring" syntax="@receivestring(message[], source[])">
			<attribute name="public"/>
			<stacksize value="1"/>
			<param name="message">
				<paraminfo> [] </paraminfo>
				Contains the message (a zero-terminated string) that was received.
			</param>
			<param name="source">
				<paraminfo> [] </paraminfo>
				Contains the IP address and the port number of the sender of this packet.
			</param>
			<summary>A packed was received.</summary>   <seealso name="@receivepacket"/> <seealso name="sendstring"/> <remarks>The string is in unpacked format if the original packet contained a string in UTF-8 format. Note that messages in the ASCII character set are also UTF-8 compliant.</remarks> <remarks>This function does not work in the current SA:MP version!</remarks> <returns>The return value of this function is currently ignored.</returns>
		</member>
		<member name="M:CombineMatrix" syntax="CombineMatrix(left[], right[], dest[])">
			<stacksize value="1"/>
			<referrer name="NormalizeMatrix"/>
			<referrer name="CombineRotation"/>
			<dependency name="operator+(Float:,Float:)"/>
			<dependency name="operator*(Float:,Float:)"/>
			<dependency name="E_RMATRIX_00"/>
			<dependency name="E_RMATRIX_01"/>
			<dependency name="E_RMATRIX_02"/>
			<dependency name="E_RMATRIX_10"/>
			<dependency name="E_RMATRIX_11"/>
			<dependency name="E_RMATRIX_12"/>
			<dependency name="E_RMATRIX_20"/>
			<dependency name="E_RMATRIX_21"/>
			<dependency name="E_RMATRIX_22"/>
			<dependency name="m100"/>
			<dependency name="m101"/>
			<dependency name="m102"/>
			<dependency name="m110"/>
			<dependency name="m111"/>
			<dependency name="m112"/>
			<dependency name="m120"/>
			<dependency name="m121"/>
			<dependency name="m122"/>
			<dependency name="m200"/>
			<dependency name="m201"/>
			<dependency name="m202"/>
			<dependency name="m210"/>
			<dependency name="m211"/>
			<dependency name="m212"/>
			<dependency name="m220"/>
			<dependency name="m221"/>
			<dependency name="m222"/>
			<param name="left">
				<paraminfo> [9] </paraminfo>
				Left rotation matrix [<ref name="E_RMATRIX"/>]
			</param>
			<param name="right">
				<paraminfo> [9] </paraminfo>
				Right rotation matrix [<ref name="E_RMATRIX"/>]
			</param>
			<param name="dest">
				<paraminfo> [9] </paraminfo>
				Dest rotation matrix [<ref name="E_RMATRIX"/>]
			</param>
			<summary>Combines two rotation matrices</summary> <export>rmatrix</export>   
		</member>
		<member name="M:CombineQuat" syntax="CombineQuat(left[], right[], dest[])">
			<stacksize value="1"/>
			<referrer name="CombineRotation"/>
			<dependency name="operator-(Float:,Float:)"/>
			<dependency name="operator+(Float:,Float:)"/>
			<dependency name="operator*(Float:,Float:)"/>
			<dependency name="E_QUAT_W"/>
			<dependency name="E_QUAT_X"/>
			<dependency name="E_QUAT_Y"/>
			<dependency name="E_QUAT_Z"/>
			<dependency name="w1"/>
			<dependency name="w2"/>
			<dependency name="x1"/>
			<dependency name="x2"/>
			<dependency name="y1"/>
			<dependency name="y2"/>
			<dependency name="z1"/>
			<dependency name="z2"/>
			<param name="left">
				<paraminfo> [4] </paraminfo>
				Left quaternion [<ref name="E_QUAT"/>]
			</param>
			<param name="right">
				<paraminfo> [4] </paraminfo>
				Right quaternion [<ref name="E_QUAT"/>]
			</param>
			<param name="dest">
				<paraminfo> [4] </paraminfo>
				Dest quaternion [<ref name="E_QUAT"/>]
			</param>
			<summary>Combines two quaternion</summary>   
		</member>
		<member name="M:CombineRotation" syntax="CombineRotation(left[], right[], dest[])">
			<stacksize value="6"/>
			<dependency name="CombineMatrix"/>
			<dependency name="CombineQuat"/>
			<dependency name="ConvertRotation"/>
			<dependency name="E_ROTATION_TYPE"/>
			<dependency name="rtype_quaternion"/>
			<dependency name="rtype_rotation_matrix"/>
			<param name="left">
				<paraminfo> [10] </paraminfo>
				Left rotation [<ref name="E_AANGLE"/>]
			</param>
			<param name="right">
				<paraminfo> [10] </paraminfo>
				Right rotation [<ref name="E_AANGLE"/>]
			</param>
			<param name="dest">
				<paraminfo> [10] </paraminfo>
				Dest rotation [<ref name="E_AANGLE"/>]
			</param>
			<summary>Combines two rotations, left * right = dest</summary> <export/>    <remarks>If <paramref name="left"/> or <paramref name="right"/> is a rotation matrix than <paramref name="left"/>, <paramref name="right"/> and <paramref name="dest"/> will be converted to rotation matrices, in all other cases <paramref name="left"/>, <paramref name="right"/> and <paramref name="dest"/> will be quaternion</remarks> <remarks>[second Rotation] * [first Rotation] = global frame of reference - global coordinate system / axis stay the same for the second rotation</remarks> <remarks>[first Rotation] * [second Rotation] = local frame-of-reference - coordinate system / axis rotates with first rotation</remarks>
		</member>
		<member name="M:ConvertAxisAngleToEuler" syntax="ConvertAxisAngleToEuler(aangle[], type[], euler[])">
			<stacksize value="10"/>
			<referrer name="ConvertRotation"/>
			<dependency name="ConvertAxisAngleToQuat"/>
			<dependency name="ConvertQuatToEuler"/>
			<dependency name="E_QUAT"/>
			<dependency name="rtype_axis_angle"/>
			<dependency name="rtype_quaternion"/>
			<param name="aangle">
				<paraminfo> [4] </paraminfo>
				Source axis angle [<ref name="E_AANGLE"/>]
			</param>
			<param name="type">
				<paraminfo>rotationtype [2] </paraminfo>
				Rotation type
			</param>
			<param name="euler">
				<paraminfo> [3] </paraminfo>
				Dest euler angle [<ref name="E_EULER"/>]
			</param>
			<summary>Convert the given axis angle into euler angle</summary> <export>euler</export>    <remarks>Not optimized, uses <ref name="ConvertAxisAngleToQuat"/> and <ref name="ConvertQuatToEuler"/> for the conversion</remarks>
		</member>
		<member name="M:ConvertAxisAngleToMatrix" syntax="ConvertAxisAngleToMatrix(aangle[], type[], rmatrix[])">
			<stacksize value="10"/>
			<referrer name="ConvertRotation"/>
			<dependency name="operator-(Float:,Float:)"/>
			<dependency name="operator+(Float:,Float:)"/>
			<dependency name="operator*(Float:,Float:)"/>
			<dependency name="E_AANGLE_ANGLE"/>
			<dependency name="E_AANGLE_X"/>
			<dependency name="E_AANGLE_Y"/>
			<dependency name="E_AANGLE_Z"/>
			<dependency name="E_RMATRIX_00"/>
			<dependency name="E_RMATRIX_01"/>
			<dependency name="E_RMATRIX_02"/>
			<dependency name="E_RMATRIX_10"/>
			<dependency name="E_RMATRIX_11"/>
			<dependency name="E_RMATRIX_12"/>
			<dependency name="E_RMATRIX_20"/>
			<dependency name="E_RMATRIX_21"/>
			<dependency name="E_RMATRIX_22"/>
			<dependency name="degrees"/>
			<dependency name="floatcos"/>
			<dependency name="floatsin"/>
			<param name="aangle">
				<paraminfo> [4] </paraminfo>
				Source axis angle [<ref name="E_AANGLE"/>]
			</param>
			<param name="type">
				<paraminfo>rotationtype [2] </paraminfo>
				Rotation type, unused
			</param>
			<param name="rmatrix">
				<paraminfo> [9] </paraminfo>
				Dest rotation matrix [<ref name="E_RMATRIX"/>]
			</param>
			<summary>Convert the given axis angle into a rotation matrix</summary> <export>rmatrix</export>   
		</member>
		<member name="M:ConvertAxisAngleToQuat" syntax="ConvertAxisAngleToQuat(aangle[], type[], quat[])">
			<stacksize value="6"/>
			<referrer name="ConvertAxisAngleToEuler"/>
			<referrer name="ConvertRotation"/>
			<dependency name="operator/(Float:,Float:)"/>
			<dependency name="operator*(Float:,Float:)"/>
			<dependency name="operator==(Float:,Float:)"/>
			<dependency name="E_AANGLE_ANGLE"/>
			<dependency name="E_AANGLE_X"/>
			<dependency name="E_AANGLE_Y"/>
			<dependency name="E_AANGLE_Z"/>
			<dependency name="E_QUAT_W"/>
			<dependency name="E_QUAT_X"/>
			<dependency name="E_QUAT_Y"/>
			<dependency name="E_QUAT_Z"/>
			<dependency name="VectorSize"/>
			<dependency name="degrees"/>
			<dependency name="floatcos"/>
			<dependency name="floatsin"/>
			<param name="aangle">
				<paraminfo> [4] </paraminfo>
				Source axis angle [<ref name="E_AANGLE"/>]
			</param>
			<param name="type">
				<paraminfo>rotationtype [2] </paraminfo>
				Rotation type, unused
			</param>
			<param name="quat">
				<paraminfo> [4] </paraminfo>
				Dest quaternion [<ref name="E_QUAT"/>]
			</param>
			<summary>Convert the given axis angle into quaternion</summary> <export>quat</export>   
		</member>
		<member name="M:ConvertEulerToAxisAngle" syntax="ConvertEulerToAxisAngle(euler[], type[], aangle[])">
			<stacksize value="10"/>
			<referrer name="ConvertRotation"/>
			<dependency name="ConvertEulerToQuat"/>
			<dependency name="ConvertQuatToAxisAngle"/>
			<dependency name="E_QUAT"/>
			<dependency name="rtype_axis_angle"/>
			<dependency name="rtype_quaternion"/>
			<param name="euler">
				<paraminfo> [3] </paraminfo>
				Source euler angle [<ref name="E_EULER"/>]
			</param>
			<param name="type">
				<paraminfo>rotationtype [2] </paraminfo>
				Rotation type, unused
			</param>
			<param name="aangle">
				<paraminfo> [4] </paraminfo>
				Dest axis angle [<ref name="E_AANGLE"/>]
			</param>
			<summary>Convert the given euler angle into axis angle</summary> <export>aangle</export>    <remarks>Not optimized, uses <ref name="ConvertEulerToQuat"/> and <ref name="ConvertQuatToAxisAngle"/> for the conversion</remarks>
		</member>
		<member name="M:ConvertEulerToEuler" syntax="ConvertEulerToEuler(src[], type[], dest[])">
			<stacksize value="12"/>
			<referrer name="ConvertRotation"/>
			<dependency name="ConvertEulerToQuat"/>
			<dependency name="ConvertQuatToEuler"/>
			<dependency name="E_QUAT"/>
			<dependency name="rtype_quaternion"/>
			<param name="src">
				<paraminfo> [3] </paraminfo>
				Source euler angle [<ref name="E_EULER"/>]
			</param>
			<param name="type">
				<paraminfo>rotationtype [2] </paraminfo>
				Rotation type
			</param>
			<param name="dest">
				<paraminfo> [3] </paraminfo>
				Dest euler angle [<ref name="E_EULER"/>]
			</param>
			<summary>Convert the given euler angle into euler angle</summary> <export>euler</export>    <remarks>Not optimized, uses <ref name="ConvertEulerToQuat"/> and <ref name="ConvertQuatToEuler"/> for the conversion</remarks> <remarks>Doesn't check for same rotation type, that case should be caught in <ref name="ConvertRotation"/></remarks>
		</member>
		<member name="M:ConvertEulerToMatrix" syntax="ConvertEulerToMatrix(euler[], type[], rmatrix[])">
			<stacksize value="13"/>
			<referrer name="ConvertRotation"/>
			<dependency name="operator-(Float:)"/>
			<dependency name="operator-(Float:,Float:)"/>
			<dependency name="operator+(Float:,Float:)"/>
			<dependency name="operator*(Float:,Float:)"/>
			<dependency name="E_EULER_ALPHA"/>
			<dependency name="E_EULER_BETA"/>
			<dependency name="E_EULER_GAMMA"/>
			<dependency name="E_RMATRIX_00"/>
			<dependency name="E_RMATRIX_01"/>
			<dependency name="E_RMATRIX_02"/>
			<dependency name="E_RMATRIX_10"/>
			<dependency name="E_RMATRIX_11"/>
			<dependency name="E_RMATRIX_12"/>
			<dependency name="E_RMATRIX_20"/>
			<dependency name="E_RMATRIX_21"/>
			<dependency name="E_RMATRIX_22"/>
			<dependency name="degrees"/>
			<dependency name="floatcos"/>
			<dependency name="floatsin"/>
			<dependency name="rtype_euler_re_xzy"/>
			<dependency name="rtype_euler_re_yxz"/>
			<dependency name="rtype_euler_re_yzx"/>
			<dependency name="rtype_euler_re_zxy"/>
			<dependency name="rtype_euler_re_zyx"/>
			<dependency name="rtype_euler_xyx"/>
			<dependency name="rtype_euler_xyz"/>
			<dependency name="rtype_euler_xzx"/>
			<dependency name="rtype_euler_xzy"/>
			<dependency name="rtype_euler_yxy"/>
			<dependency name="rtype_euler_yxz"/>
			<dependency name="rtype_euler_yzx"/>
			<dependency name="rtype_euler_yzy"/>
			<dependency name="rtype_euler_zxy"/>
			<dependency name="rtype_euler_zxz"/>
			<dependency name="rtype_euler_zyx"/>
			<dependency name="rtype_euler_zyz"/>
			<param name="euler">
				<paraminfo> [3] </paraminfo>
				Source euler angle [<ref name="E_EULER"/>]
			</param>
			<param name="type">
				<paraminfo>rotationtype [2] </paraminfo>
				Rotation type
			</param>
			<param name="rmatrix">
				<paraminfo> [9] </paraminfo>
				Dest rotation matrix [<ref name="E_RMATRIX"/>]
			</param>
			<summary>Convert the given euler angle into a rotation matrix</summary> <export>rmatrix</export>   
		</member>
		<member name="M:ConvertEulerToQuat" syntax="ConvertEulerToQuat(euler[], type[], quat[])">
			<stacksize value="13"/>
			<referrer name="ConvertEulerToEuler"/>
			<referrer name="ConvertEulerToAxisAngle"/>
			<referrer name="ConvertRotation"/>
			<dependency name="operator-(Float:)"/>
			<dependency name="operator-(Float:,Float:)"/>
			<dependency name="operator+(Float:,Float:)"/>
			<dependency name="operator*(Float:,Float:)"/>
			<dependency name="E_EULER_ALPHA"/>
			<dependency name="E_EULER_BETA"/>
			<dependency name="E_EULER_GAMMA"/>
			<dependency name="E_QUAT_W"/>
			<dependency name="E_QUAT_X"/>
			<dependency name="E_QUAT_Y"/>
			<dependency name="E_QUAT_Z"/>
			<dependency name="degrees"/>
			<dependency name="floatcos"/>
			<dependency name="floatsin"/>
			<dependency name="rtype_euler_re_xzy"/>
			<dependency name="rtype_euler_re_yxz"/>
			<dependency name="rtype_euler_re_yzx"/>
			<dependency name="rtype_euler_re_zxy"/>
			<dependency name="rtype_euler_re_zyx"/>
			<dependency name="rtype_euler_xyx"/>
			<dependency name="rtype_euler_xyz"/>
			<dependency name="rtype_euler_xzx"/>
			<dependency name="rtype_euler_xzy"/>
			<dependency name="rtype_euler_yxy"/>
			<dependency name="rtype_euler_yxz"/>
			<dependency name="rtype_euler_yzx"/>
			<dependency name="rtype_euler_yzy"/>
			<dependency name="rtype_euler_zxy"/>
			<dependency name="rtype_euler_zxz"/>
			<dependency name="rtype_euler_zyx"/>
			<dependency name="rtype_euler_zyz"/>
			<param name="euler">
				<paraminfo> [3] </paraminfo>
				Source euler angle [<ref name="E_EULER"/>]
			</param>
			<param name="type">
				<paraminfo>rotationtype [2] </paraminfo>
				Rotation type
			</param>
			<param name="quat">
				<paraminfo> [4] </paraminfo>
				Dest quaternion [<ref name="E_QUAT"/>]
			</param>
			<summary>Convert the given euler angle into quaternion</summary> <export>quat</export>   
		</member>
		<member name="M:ConvertMatrixToAxisAngle" syntax="ConvertMatrixToAxisAngle(rmatrix[], type[], aangle[])">
			<stacksize value="9"/>
			<referrer name="ConvertRotation"/>
			<dependency name="operator-(Float:,Float:)"/>
			<dependency name="operator+(Float:,Float:)"/>
			<dependency name="operator/(Float:,Float:)"/>
			<dependency name="E_AANGLE_ANGLE"/>
			<dependency name="E_AANGLE_X"/>
			<dependency name="E_AANGLE_Y"/>
			<dependency name="E_AANGLE_Z"/>
			<dependency name="E_RMATRIX_00"/>
			<dependency name="E_RMATRIX_01"/>
			<dependency name="E_RMATRIX_02"/>
			<dependency name="E_RMATRIX_10"/>
			<dependency name="E_RMATRIX_11"/>
			<dependency name="E_RMATRIX_12"/>
			<dependency name="E_RMATRIX_20"/>
			<dependency name="E_RMATRIX_21"/>
			<dependency name="E_RMATRIX_22"/>
			<dependency name="VectorSize"/>
			<dependency name="acos"/>
			<param name="rmatrix">
				<paraminfo> [9] </paraminfo>
				Source rotation matrix [<ref name="E_RMATRIX"/>]
			</param>
			<param name="type">
				<paraminfo>rotationtype [2] </paraminfo>
				Rotation type, unused
			</param>
			<param name="aangle">
				<paraminfo> [4] </paraminfo>
				Dest axis angle [<ref name="E_AANGLE"/>]
			</param>
			<summary>Convert the given rotation matrix into axis angle</summary> <export>aangle</export>   
		</member>
		<member name="M:ConvertMatrixToEuler" syntax="ConvertMatrixToEuler(rmatrix[], type[], euler[])">
			<stacksize value="5"/>
			<referrer name="ConvertRotation"/>
			<dependency name="operator-(Float:)"/>
			<dependency name="operator&gt;(Float:,Float:)"/>
			<dependency name="operator&lt;(Float:,Float:)"/>
			<dependency name="E_EULER_ALPHA"/>
			<dependency name="E_EULER_BETA"/>
			<dependency name="E_EULER_GAMMA"/>
			<dependency name="E_RMATRIX_00"/>
			<dependency name="E_RMATRIX_01"/>
			<dependency name="E_RMATRIX_02"/>
			<dependency name="E_RMATRIX_10"/>
			<dependency name="E_RMATRIX_11"/>
			<dependency name="E_RMATRIX_12"/>
			<dependency name="E_RMATRIX_20"/>
			<dependency name="E_RMATRIX_21"/>
			<dependency name="E_RMATRIX_22"/>
			<dependency name="acos"/>
			<dependency name="asin"/>
			<dependency name="atan2"/>
			<dependency name="rtype_euler_re_xzy"/>
			<dependency name="rtype_euler_re_yxz"/>
			<dependency name="rtype_euler_re_yzx"/>
			<dependency name="rtype_euler_re_zxy"/>
			<dependency name="rtype_euler_re_zyx"/>
			<dependency name="rtype_euler_xyx"/>
			<dependency name="rtype_euler_xyz"/>
			<dependency name="rtype_euler_xzx"/>
			<dependency name="rtype_euler_xzy"/>
			<dependency name="rtype_euler_yxy"/>
			<dependency name="rtype_euler_yxz"/>
			<dependency name="rtype_euler_yzx"/>
			<dependency name="rtype_euler_yzy"/>
			<dependency name="rtype_euler_zxy"/>
			<dependency name="rtype_euler_zxz"/>
			<dependency name="rtype_euler_zyx"/>
			<dependency name="rtype_euler_zyz"/>
			<param name="rmatrix">
				<paraminfo> [9] </paraminfo>
				Source rotation matrix [<ref name="E_RMATRIX"/>]
			</param>
			<param name="type">
				<paraminfo>rotationtype [2] </paraminfo>
				Rotation type
			</param>
			<param name="euler">
				<paraminfo> [3] </paraminfo>
				Dest euler angle [<ref name="E_EULER"/>]
			</param>
			<summary>Convert the given rotation matrix into euler angle</summary> <export>euler</export>   
		</member>
		<member name="M:ConvertMatrixToQuat" syntax="ConvertMatrixToQuat(rmatrix[], type[], quat[])">
			<stacksize value="7"/>
			<referrer name="ConvertRotation"/>
			<dependency name="operator-(Float:,Float:)"/>
			<dependency name="operator+(Float:,Float:)"/>
			<dependency name="operator/(Float:,Float:)"/>
			<dependency name="operator*(Float:,Float:)"/>
			<dependency name="operator&gt;(Float:,Float:)"/>
			<dependency name="E_QUAT_W"/>
			<dependency name="E_QUAT_X"/>
			<dependency name="E_QUAT_Y"/>
			<dependency name="E_QUAT_Z"/>
			<dependency name="E_RMATRIX_00"/>
			<dependency name="E_RMATRIX_01"/>
			<dependency name="E_RMATRIX_02"/>
			<dependency name="E_RMATRIX_10"/>
			<dependency name="E_RMATRIX_11"/>
			<dependency name="E_RMATRIX_12"/>
			<dependency name="E_RMATRIX_20"/>
			<dependency name="E_RMATRIX_21"/>
			<dependency name="E_RMATRIX_22"/>
			<dependency name="floatsqroot"/>
			<param name="rmatrix">
				<paraminfo> [9] </paraminfo>
				Source rotation matrix [<ref name="E_RMATRIX"/>]
			</param>
			<param name="type">
				<paraminfo>rotationtype [2] </paraminfo>
				Rotation type, unused
			</param>
			<param name="quat">
				<paraminfo> [4] </paraminfo>
				Dest quaternion [<ref name="E_QUAT"/>]
			</param>
			<summary>Convert the given rotation matrix into quaternion</summary> <export>quat</export>   
		</member>
		<member name="M:ConvertQuatToAxisAngle" syntax="ConvertQuatToAxisAngle(quat[], type[], aangle[])">
			<stacksize value="6"/>
			<referrer name="ConvertEulerToAxisAngle"/>
			<referrer name="ConvertRotation"/>
			<dependency name="operator-(Float:)"/>
			<dependency name="operator/(Float:,Float:)"/>
			<dependency name="operator*(Float:,Float:)"/>
			<dependency name="operator==(Float:,Float:)"/>
			<dependency name="E_AANGLE_ANGLE"/>
			<dependency name="E_AANGLE_X"/>
			<dependency name="E_AANGLE_Y"/>
			<dependency name="E_AANGLE_Z"/>
			<dependency name="E_QUAT_W"/>
			<dependency name="E_QUAT_X"/>
			<dependency name="E_QUAT_Y"/>
			<dependency name="E_QUAT_Z"/>
			<dependency name="VectorSize"/>
			<dependency name="acos"/>
			<param name="quat">
				<paraminfo> [4] </paraminfo>
				Source quaternion [<ref name="E_QUAT"/>]
			</param>
			<param name="type">
				<paraminfo>rotationtype [2] </paraminfo>
				Rotation type, unused
			</param>
			<param name="aangle">
				<paraminfo> [4] </paraminfo>
				Dest axis angle [<ref name="E_AANGLE"/>]
			</param>
			<summary>Convert the given quaternion into axis angle</summary> <export>aangle</export>   
		</member>
		<member name="M:ConvertQuatToEuler" syntax="ConvertQuatToEuler(quat[], type[], euler[])">
			<stacksize value="9"/>
			<referrer name="ConvertAxisAngleToEuler"/>
			<referrer name="ConvertEulerToEuler"/>
			<referrer name="ConvertRotation"/>
			<dependency name="operator-(Float:)"/>
			<dependency name="operator-(Float:,Float:)"/>
			<dependency name="operator+(Float:,Float:)"/>
			<dependency name="operator*(Float:,Float:)"/>
			<dependency name="operator&gt;(Float:,Float:)"/>
			<dependency name="operator&lt;(Float:,Float:)"/>
			<dependency name="E_EULER_ALPHA"/>
			<dependency name="E_EULER_BETA"/>
			<dependency name="E_EULER_GAMMA"/>
			<dependency name="E_QUAT_W"/>
			<dependency name="E_QUAT_X"/>
			<dependency name="E_QUAT_Y"/>
			<dependency name="E_QUAT_Z"/>
			<dependency name="acos"/>
			<dependency name="asin"/>
			<dependency name="atan2"/>
			<dependency name="rtype_euler_re_xzy"/>
			<dependency name="rtype_euler_re_yxz"/>
			<dependency name="rtype_euler_re_yzx"/>
			<dependency name="rtype_euler_re_zxy"/>
			<dependency name="rtype_euler_re_zyx"/>
			<dependency name="rtype_euler_xyx"/>
			<dependency name="rtype_euler_xyz"/>
			<dependency name="rtype_euler_xzx"/>
			<dependency name="rtype_euler_xzy"/>
			<dependency name="rtype_euler_yxy"/>
			<dependency name="rtype_euler_yxz"/>
			<dependency name="rtype_euler_yzx"/>
			<dependency name="rtype_euler_yzy"/>
			<dependency name="rtype_euler_zxy"/>
			<dependency name="rtype_euler_zxz"/>
			<dependency name="rtype_euler_zyx"/>
			<dependency name="rtype_euler_zyz"/>
			<param name="quat">
				<paraminfo> [4] </paraminfo>
				Source quaternion [<ref name="E_QUAT"/>]
			</param>
			<param name="type">
				<paraminfo>rotationtype [2] </paraminfo>
				Rotation type
			</param>
			<param name="euler">
				<paraminfo> [3] </paraminfo>
				Dest euler angle [<ref name="E_EULER"/>]
			</param>
			<summary>Convert the given quaternion into euler angle</summary> <export>euler</export>    <remarks>Based on <ref name="ConvertQuatToMatrix"/> and <ref name="ConvertMatrixToEuler"/> but without calculating all matrix items</remarks>
		</member>
		<member name="M:ConvertQuatToMatrix" syntax="ConvertQuatToMatrix(quat[], type[], rmatrix[])">
			<stacksize value="15"/>
			<referrer name="ConvertRotation"/>
			<dependency name="operator-(Float:,Float:)"/>
			<dependency name="operator+(Float:,Float:)"/>
			<dependency name="operator*(Float:,Float:)"/>
			<dependency name="E_QUAT_W"/>
			<dependency name="E_QUAT_X"/>
			<dependency name="E_QUAT_Y"/>
			<dependency name="E_QUAT_Z"/>
			<dependency name="E_RMATRIX_00"/>
			<dependency name="E_RMATRIX_01"/>
			<dependency name="E_RMATRIX_02"/>
			<dependency name="E_RMATRIX_10"/>
			<dependency name="E_RMATRIX_11"/>
			<dependency name="E_RMATRIX_12"/>
			<dependency name="E_RMATRIX_20"/>
			<dependency name="E_RMATRIX_21"/>
			<dependency name="E_RMATRIX_22"/>
			<param name="quat">
				<paraminfo> [4] </paraminfo>
				Source quaternion [<ref name="E_QUAT"/>]
			</param>
			<param name="type">
				<paraminfo>rotationtype [2] </paraminfo>
				Rotation type, unused
			</param>
			<param name="rmatrix">
				<paraminfo> [9] </paraminfo>
				Dest rotation matrix [<ref name="E_RMATRIX"/>]
			</param>
			<summary>Convert the given quaternion into a rotation matrix</summary> <export>rmatrix</export>   
		</member>
		<member name="M:ConvertRotation" syntax="ConvertRotation(src[], type, dest[])">
			<stacksize value="1"/>
			<referrer name="CombineRotation"/>
			<referrer name="GetRotation"/>
			<referrer name="RotatePoint"/>
			<dependency name="ConvertAxisAngleToEuler"/>
			<dependency name="ConvertAxisAngleToMatrix"/>
			<dependency name="ConvertAxisAngleToQuat"/>
			<dependency name="ConvertEulerToAxisAngle"/>
			<dependency name="ConvertEulerToEuler"/>
			<dependency name="ConvertEulerToMatrix"/>
			<dependency name="ConvertEulerToQuat"/>
			<dependency name="ConvertMatrixToAxisAngle"/>
			<dependency name="ConvertMatrixToEuler"/>
			<dependency name="ConvertMatrixToQuat"/>
			<dependency name="ConvertQuatToAxisAngle"/>
			<dependency name="ConvertQuatToEuler"/>
			<dependency name="ConvertQuatToMatrix"/>
			<dependency name="E_ROTATION_TYPE"/>
			<dependency name="rtype_axis_angle"/>
			<dependency name="rtype_quaternion"/>
			<dependency name="rtype_rotation_matrix"/>
			<param name="src">
				<paraminfo> [10] </paraminfo>
				Source rotation array
			</param>
			<param name="type">
				<paraminfo>rotationtype </paraminfo>
				Dest rotation type
			</param>
			<param name="dest">
				<paraminfo> [10] </paraminfo>
				Dest rotation array
			</param>
			<summary>Convert the given rotation matrix into the target rotation</summary> <export/>   
		</member>
		<member name="M:GetAxisAngleFromRotation" syntax="GetAxisAngleFromRotation(aangle[], type, &amp;angle, &amp;x, &amp;y, &amp;z)">
			<stacksize value="1"/>
			<referrer name="GetRotation"/>
			<dependency name="E_AANGLE_ANGLE"/>
			<dependency name="E_AANGLE_X"/>
			<dependency name="E_AANGLE_Y"/>
			<dependency name="E_AANGLE_Z"/>
			<param name="aangle">
				<paraminfo> [4] </paraminfo>
				Axis angle array [<ref name="E_AANGLE"/>]
			</param>
			<param name="type">
				<paraminfo>rotationtype </paraminfo>
				Dest rotation type, unused
			</param>
			<param name="angle">
				<paraminfo>Float &amp; </paraminfo>
				Dest axis angle rotation
			</param>
			<param name="x">
				<paraminfo>Float &amp; </paraminfo>
				Dest axis angle unit vector x
			</param>
			<param name="y">
				<paraminfo>Float &amp; </paraminfo>
				Dest axis angle unit vector y
			</param>
			<param name="z">
				<paraminfo>Float &amp; </paraminfo>
				Dest axis angle unit vector z
			</param>
			<summary>Get the axis angle from the rotation array</summary> <export>aangle</export>      
		</member>
		<member name="M:GetEulerFromRotation" syntax="GetEulerFromRotation(euler[], type, &amp;alpha, &amp;beta, &amp;gamma)">
			<stacksize value="1"/>
			<referrer name="GetRotation"/>
			<dependency name="E_EULER_ALPHA"/>
			<dependency name="E_EULER_BETA"/>
			<dependency name="E_EULER_GAMMA"/>
			<param name="euler">
				<paraminfo> [3] </paraminfo>
				Euler angle array [<ref name="E_EULER"/>]
			</param>
			<param name="type">
				<paraminfo>rotationtype </paraminfo>
				Dest rotation type, unused
			</param>
			<param name="alpha">
				<paraminfo>Float &amp; </paraminfo>
				First dest euler angle
			</param>
			<param name="beta">
				<paraminfo>Float &amp; </paraminfo>
				Second dest euler angle
			</param>
			<param name="gamma">
				<paraminfo>Float &amp; </paraminfo>
				Third dest euler angle
			</param>
			<summary>Gets the euler angle from the rotation array</summary> <export>euler</export>     
		</member>
		<member name="M:GetMatrixFromRotation" syntax="GetMatrixFromRotation(rmatrix[], type, matrix[][])">
			<stacksize value="1"/>
			<referrer name="GetRotation"/>
			<dependency name="m100"/>
			<dependency name="m101"/>
			<dependency name="m102"/>
			<dependency name="m110"/>
			<dependency name="m111"/>
			<dependency name="m112"/>
			<dependency name="m120"/>
			<dependency name="m121"/>
			<dependency name="m122"/>
			<param name="rmatrix">
				<paraminfo> [9] </paraminfo>
				Rotation matrix array [<ref name="E_RMATRIX"/>]
			</param>
			<param name="type">
				<paraminfo>rotationtype </paraminfo>
				Dest rotation type, unused
			</param>
			<param name="matrix">
				<paraminfo>Float [][] </paraminfo>
				Dest matrix
			</param>
			<summary>Get the matrix from the rotation array</summary> <export>rmatrix</export>   
		</member>
		<member name="M:GetQuatFromRotation" syntax="GetQuatFromRotation(quat[], type, &amp;w, &amp;x, &amp;y, &amp;z)">
			<stacksize value="1"/>
			<referrer name="GetRotation"/>
			<dependency name="E_QUAT_W"/>
			<dependency name="E_QUAT_X"/>
			<dependency name="E_QUAT_Y"/>
			<dependency name="E_QUAT_Z"/>
			<param name="quat">
				<paraminfo> [4] </paraminfo>
				Quaternion array [<ref name="E_QUAT"/>]
			</param>
			<param name="type">
				<paraminfo>rotationtype </paraminfo>
				Dest rotation type, unused
			</param>
			<param name="w">
				<paraminfo>Float &amp; </paraminfo>
				Dest quaternion scalar part
			</param>
			<param name="x">
				<paraminfo>Float &amp; </paraminfo>
				Dest quaternion imaginary part x
			</param>
			<param name="y">
				<paraminfo>Float &amp; </paraminfo>
				Dest quaternion imaginary part y
			</param>
			<param name="z">
				<paraminfo>Float &amp; </paraminfo>
				Dest quaternion imaginary part z
			</param>
			<summary>Get the quaternion from the rotation array</summary> <export>quat</export>      
		</member>
		<member name="M:GetRotation" syntax="GetRotation(rotation[], type, ...)">
			<stacksize value="6"/>
			<dependency name="ConvertRotation"/>
			<dependency name="E_ROTATION"/>
			<dependency name="GetAxisAngleFromRotation"/>
			<dependency name="GetEulerFromRotation"/>
			<dependency name="GetMatrixFromRotation"/>
			<dependency name="GetQuatFromRotation"/>
			<dependency name="rtype_axis_angle"/>
			<dependency name="rtype_quaternion"/>
			<dependency name="rtype_rotation_matrix"/>
			<param name="rotation">
				<paraminfo> [10] </paraminfo>
				Rotation array [<ref name="E_ROTATION"/>]
			</param>
			<param name="type">
				<paraminfo>rotationtype </paraminfo>
				Dest rotation type
			</param>
			<param name="...">
				<paraminfo>Float </paraminfo>
			</param>
			<summary>Get the rotation from the given rotation array</summary> <export/>   <param name="...">Dest rotation</param>
		</member>
		<member name="M:NormalizeAxisAngle" syntax="NormalizeAxisAngle(aangle[])">
			<stacksize value="6"/>
			<referrer name="SetRotationFromAxisAngle"/>
			<dependency name="operator/(Float:,Float:)"/>
			<dependency name="E_AANGLE_X"/>
			<dependency name="E_AANGLE_Y"/>
			<dependency name="E_AANGLE_Z"/>
			<dependency name="VectorSize"/>
			<param name="aangle">
				<paraminfo> [4] </paraminfo>
				Axis angle array [<ref name="E_AANGLE"/>]
			</param>
			<summary>Normalizes axis angle</summary> <export>aangle</export> 
		</member>
		<member name="M:NormalizeMatrix" syntax="NormalizeMatrix(rmatrix[])">
			<stacksize value="25"/>
			<referrer name="SetRotationFromMatrix"/>
			<dependency name="operator!=(Float:,Float:)"/>
			<dependency name="operator-(Float:)"/>
			<dependency name="operator/(Float:,Float:)"/>
			<dependency name="CombineMatrix"/>
			<dependency name="E_RMATRIX"/>
			<dependency name="E_RMATRIX_00"/>
			<dependency name="E_RMATRIX_01"/>
			<dependency name="E_RMATRIX_02"/>
			<dependency name="E_RMATRIX_10"/>
			<dependency name="E_RMATRIX_11"/>
			<dependency name="E_RMATRIX_12"/>
			<dependency name="E_RMATRIX_20"/>
			<dependency name="E_RMATRIX_21"/>
			<dependency name="E_RMATRIX_22"/>
			<dependency name="VectorSize"/>
			<param name="rmatrix">
				<paraminfo> [9] </paraminfo>
				Rotation matrix [<ref name="E_RMATRIX"/>]
			</param>
			<summary>Normalizes rotation matrix with Givens-Rotations</summary> <export>rmatrix</export> 
		</member>
		<member name="M:NormalizeQuat" syntax="NormalizeQuat(quat[])">
			<stacksize value="7"/>
			<referrer name="SetRotationFromQuat"/>
			<dependency name="operator/(Float:,Float:)"/>
			<dependency name="E_QUAT_W"/>
			<dependency name="E_QUAT_X"/>
			<dependency name="E_QUAT_Y"/>
			<dependency name="E_QUAT_Z"/>
			<dependency name="VectorSize"/>
			<param name="quat">
				<paraminfo> [4] </paraminfo>
				Quaternion array [<ref name="E_QUAT"/>]
			</param>
			<summary>Normalizes quaternion</summary> <export>quat</export> 
		</member>
		<member name="M:OnActorStreamIn" syntax="OnActorStreamIn(actorid, forplayerid)">
			<stacksize value="1"/>
			<param name="actorid">
				The ID of the actor that has been streamed in for the player
			</param>
			<param name="forplayerid">
				The ID of the player that streamed the actor in
			</param>
			<summary>This callback is called when an actor is streamed in by a player's client.</summary>   <seealso name="OnActorStreamOut"/> <seealso name="OnPlayerStreamIn"/> <remarks>This function was added in <b>SA-MP 0.3.7</b> and will not work in earlier versions!</remarks> <remarks>This callback can also be called by NPC.</remarks> <remarks>It is always called first in filterscripts.</remarks> <returns>This callback does not handle returns.</returns>
		</member>
		<member name="M:OnActorStreamOut" syntax="OnActorStreamOut(actorid, forplayerid)">
			<stacksize value="1"/>
			<param name="actorid">
				The ID of the actor that has been streamed out for the player
			</param>
			<param name="forplayerid">
				The ID of the player that streamed the actor out
			</param>
			<summary>This callback is called when an actor is streamed out by a player's client.</summary>   <seealso name="OnActorStreamIn"/> <seealso name="OnPlayerStreamOut"/> <remarks>This function was added in <b>SA-MP 0.3.7</b> and will not work in earlier versions!</remarks> <remarks>This callback can also be called by NPC.</remarks> <remarks>It is always called first in filterscripts.</remarks> <returns>This callback does not handle returns.</returns>
		</member>
		<member name="M:OnDialogResponse" syntax="OnDialogResponse(playerid, dialogid, response, listitem, inputtext[])">
			<stacksize value="1"/>
			<param name="playerid">
				The ID of the player that responded to the dialog
			</param>
			<param name="dialogid">
				The ID of the dialog the player responded to, assigned in ShowPlayerDialog
			</param>
			<param name="response">
				<b><c>1</c></b> for left button and <b><c>0</c></b> for right button (if only one button shown, always <b><c>1</c></b>)
			</param>
			<param name="listitem">
				The ID of the list item selected by the player (starts at <b><c>0</c></b>) (only if using a list style dialog)
			</param>
			<param name="inputtext">
				<paraminfo> [] </paraminfo>
				The text entered into the input box by the player or the selected list item text
			</param>
			<summary>This callback is called when a player responds to a dialog shown using <a href="#ShowPlayerDialog">ShowPlayerDialog</a> by either clicking a button, pressing ENTER/ESC or double-clicking a list item (if using a list style dialog).</summary>      <seealso name="ShowPlayerDialog"/> <remarks>This callback was added in <b>SA-MP 0.3a</b> and will not work in earlier versions!</remarks> <remarks>A player's dialog doesn't hide when the gamemode restarts, causing the server to print <c>"Warning: PlayerDialogResponse PlayerId: 0 dialog ID doesn't match last sent dialog ID"</c> if a player responded to this dialog after restart.</remarks> <remarks>Parameters can contain different values, based on dialog's <a href="http://wiki.sa-mp.com/wiki/Dialog_Styles">style</a>.</remarks> <returns> Returning <b><c>0</c></b> in this callback will pass the dialog to another script in case no matching code were found in your gamemode's callback.<p/> It is always called first in filterscripts so returning <b><c>1</c></b> there blocks other filterscripts from seeing it. </returns>
		</member>
		<member name="M:OnEnterExitModShop" syntax="OnEnterExitModShop(playerid, enterexit, interiorid)">
			<stacksize value="1"/>
			<param name="playerid">
				The ID of the player that entered or exited the modshop
			</param>
			<param name="enterexit">
				<b><c>1</c></b> if the player entered or <b><c>0</c></b> if they exited
			</param>
			<param name="interiorid">
				The interior ID of the modshop that the player is entering (or 0 if exiting)
			</param>
			<summary>This callback is called when a player enters or exits a mod shop.</summary>    <seealso name="OnVehicleMod"/> <seealso name="OnVehicleRespray"/> <seealso name="OnVehiclePaintjob"/> <seealso name="AddVehicleComponent"/> <remarks>This callback was added in <b>SA-MP 0.3a</b> and will not work in earlier versions!</remarks> <remarks>Players collide when they get into the same mod shop.</remarks> <returns> This callback does not handle returns.<p/> It is always called first in filterscripts. </returns>
		</member>
		<member name="M:OnFilterScriptExit" syntax="OnFilterScriptExit()">
			<stacksize value="1"/>
			<summary>This callback is called when a filterscript is unloaded. It is only called inside the filterscript which is unloaded.</summary> <seealso name="OnFilterScriptInit"/> <seealso name="OnGameModeInit"/> <seealso name="OnGameModeExit"/> <returns>This callback does not handle returns.</returns>
		</member>
		<member name="M:OnFilterScriptInit" syntax="OnFilterScriptInit()">
			<stacksize value="1"/>
			<summary>This callback is called when a filterscript is initialized (loaded). It is only called inside the filterscript which is starting.</summary> <seealso name="OnFilterScriptExit"/> <seealso name="OnGameModeInit"/> <seealso name="OnGameModeExit"/> <returns>This callback does not handle returns.</returns>
		</member>
		<member name="M:OnGameModeExit" syntax="OnGameModeExit()">
			<stacksize value="1"/>
			<summary>This callback is called when a gamemode ends, either through 'gmx', the server being shut down, or <a href="#GameModeExit">GameModeExit</a>.</summary> <seealso name="OnGameModeInit"/> <seealso name="OnFilterScriptExit"/> <seealso name="OnFilterScriptInit"/> <seealso name="GameModeExit"/> <remarks>This function can also be used in a filterscript to detect if the gamemode changes with RCON commands like changemode or gmx, as changing the gamemode does not reload a filterscript.</remarks> <remarks>When using OnGameModeExit in conjunction with the 'rcon gmx' console command keep in mind there is a potential for client bugs to occur an example of this is excessive <a href="#RemoveBuildingForPlayer">RemoveBuildingForPlayer</a> calls during OnGameModeInit which could result in a client crash. </remarks> <remarks>This callback will NOT be called if the server crashes or the process is killed by other means, such as using the Linux kill command or pressing the close-button on the Windows console. </remarks> <returns> <b><c>0</c></b> - Will prevent other filterscripts from receiving this callback.<p/> <b><c>1</c></b> - Indicates that this callback will be passed to the next filterscript.<p/> It is always called first in gamemode. </returns>
		</member>
		<member name="M:OnGameModeInit" syntax="OnGameModeInit()">
			<stacksize value="1"/>
			<summary>This callback is triggered when the gamemode starts.</summary> <seealso name="OnGameModeExit"/> <seealso name="OnFilterScriptInit"/> <seealso name="OnFilterScriptExit"/> <remarks>This function can also be used in a filterscript to detect if the gamemode changes with RCON commands like changemode or gmx, as changing the gamemode does not reload a filterscript.</remarks> <returns> <b><c>0</c></b> - Will prevent other filterscripts from receiving this callback.<p/> <b><c>1</c></b> - Indicates that this callback will be passed to the next filterscript.<p/> It is always called first in gamemode. </returns>
		</member>
		<member name="M:OnIncomingConnection" syntax="OnIncomingConnection(playerid, ip_address[], port)">
			<stacksize value="1"/>
			<param name="playerid">
				The ID of the player attempting to connect
			</param>
			<param name="ip_address">
				<paraminfo> [] </paraminfo>
				The IP address of the player attempting to connect
			</param>
			<param name="port">
				The port of the attempted connection
			</param>
			<summary>This callback is called when an IP address attempts a connection to the server. To block incoming connections, use <a href="#BlockIpAddress">BlockIpAddress</a>.</summary>    <seealso name="OnPlayerConnect"/> <seealso name="OnPlayerDisconnect"/> <seealso name="OnPlayerFinishedDownloading"/> <seealso name="BlockIpAddress"/> <seealso name="UnBlockIpAddress"/> <remarks> 	This callback was added in <b>SA-MP 0.3z R2-2</b> and will not work in earlier versions!</remarks> <returns> <b><c>1</c></b> - Will prevent other filterscripts from receiving this callback.<p/> <b><c>0</c></b> - Indicates that this callback will be passed to the next filterscript.<p/> It is always called first in filterscripts. </returns>
		</member>
		<member name="M:OnObjectMoved" syntax="OnObjectMoved(objectid)">
			<stacksize value="1"/>
			<param name="objectid">
				The ID of the object that was moved
			</param>
			<summary>This callback is called when an object is moved after <a href="#MoveObject">MoveObject</a> (when it stops moving).</summary>  <seealso name="MoveObject"/> <seealso name="IsObjectMoving"/> <seealso name="StopObject"/> <seealso name="OnPlayerObjectMoved"/> <remarks><a href="#SetObjectPos">SetObjectPos</a> does not work when used in this callback. To fix it, recreate the object.</remarks> <returns> This callback does not handle returns.<p/> It is always called first in filterscripts. </returns>
		</member>
		<member name="M:OnPlayerClickMap" syntax="OnPlayerClickMap(playerid, fX, fY, fZ)">
			<stacksize value="1"/>
			<param name="playerid">
				The ID of the player that placed a target/waypoint
			</param>
			<param name="fX">
				<paraminfo>Float </paraminfo>
				The X float coordinate where the player clicked
			</param>
			<param name="fY">
				<paraminfo>Float </paraminfo>
				The Y float coordinate where the player clicked
			</param>
			<param name="fZ">
				<paraminfo>Float </paraminfo>
				The Z float coordinate where the player clicked (inaccurate - see note below)
			</param>
			<summary>OnPlayerClickMap is called when a player places a target/waypoint on the pause menu map (by right-clicking).</summary>     <seealso name="SetPlayerPos"/> <seealso name="SetPlayerPosFindZ"/> <seealso name="GetPlayerPos"/> <remarks>This callback was added in <b>SA-MP 0.3d</b> and will not work in earlier versions!</remarks> <remarks>The Z value returned will be <b><c>0</c></b> (invalid) if it is far away from the player; use the <a href="http://forum.sa-mp.com/showthread.php?t=275492">MapAndreas plugin</a> to get a more accurate Z coordinate.</remarks> <returns> <b><c>1</c></b> - Will prevent other filterscripts from receiving this callback.<p/> <b><c>0</c></b> - Indicates that this callback will be passed to the next filterscript.<p/> It is always called first in gamemode. </returns>
		</member>
		<member name="M:OnPlayerClickPlayer" syntax="OnPlayerClickPlayer(playerid, clickedplayerid, source)">
			<stacksize value="1"/>
			<param name="playerid">
				The ID of the player that clicked on a player on the scoreboard
			</param>
			<param name="clickedplayerid">
				The ID of the player that was clicked on
			</param>
			<param name="source">
				The source of the player's click
			</param>
			<summary>Called when a player double-clicks on a player on the scoreboard.</summary>    <seealso name="OnPlayerClickTextDraw"/> <remarks>This callback was added in <b>SA-MP 0.3a</b> and will not work in earlier versions!</remarks> <remarks>There is currently only one <paramref name="source"/> (<b><c>0 - CLICK_SOURCE_SCOREBOARD</c></b>). The existence of this argument suggests that more sources may be supported in the future.</remarks> <returns> <b><c>1</c></b> - Will prevent other filterscripts from receiving this callback.<p/> <b><c>0</c></b> - Indicates that this callback will be passed to the next filterscript.<p/> It is always called first in filterscripts. </returns>
		</member>
		<member name="M:OnPlayerClickPlayerTextDraw" syntax="OnPlayerClickPlayerTextDraw(playerid, playertextid)">
			<stacksize value="1"/>
			<param name="playerid">
				The ID of the player that selected a textdraw
			</param>
			<param name="playertextid">
				<paraminfo>PlayerText </paraminfo>
				The ID of the player-textdraw that the player selected
			</param>
			<summary>This callback is called when a player clicks on a player-textdraw. It is not called when player cancels the select mode (ESC) - however, <a href="#OnPlayerClickTextDraw">OnPlayerClickTextDraw</a> is.</summary>   <seealso name="PlayerTextDrawSetSelectable"/> <seealso name="OnPlayerClickTextDraw"/> <seealso name="OnPlayerClickPlayer"/> <remarks>This callback was added in <b>SA-MP 0.3e</b> and will not work in earlier versions!</remarks> <remarks>When a player presses ESC to cancel selecting a textdraw, <a href="#OnPlayerClickTextDraw">OnPlayerClickTextDraw</a> is called with a textdraw ID of <b><c>INVALID_TEXT_DRAW</c></b>. <a href="#OnPlayerClickPlayerTextDraw">OnPlayerClickPlayerTextDraw</a> won't be called also.</remarks> <returns> Returning <b><c>1</c></b> in this callback will prevent it being called in other scripts. This should be used to signal that the textdraw on which they clicked was 'found' and no further processing is needed. You should return <b><c>0</c></b> if the textdraw on which they clicked wasn't found, just like in <a href="#OnPlayerCommandText">OnPlayerCommandText</a>.<p/> It is always called first in filterscripts so returning <b><c>1</c></b> there also blocks other scripts from seeing it. </returns>
		</member>
		<member name="M:OnPlayerClickTextDraw" syntax="OnPlayerClickTextDraw(playerid, clickedid)">
			<stacksize value="1"/>
			<param name="playerid">
				The ID of the player that clicked on the textdraw
			</param>
			<param name="clickedid">
				<paraminfo>Text </paraminfo>
				The ID of the clicked textdraw. <b><c>INVALID_TEXT_DRAW</c></b> if selection was cancelled
			</param>
			<summary>This callback is called when a player clicks on a textdraw or cancels the select mode with the Escape key.</summary>   <seealso name="OnPlayerClickPlayerTextDraw"/> <seealso name="OnPlayerClickPlayer"/> <remarks>This callback was added in <b>SA-MP 0.3e</b> and will not work in earlier versions!</remarks> <remarks>The clickable area is defined by <a href="#TextDrawTextSize">TextDrawTextSize</a>. The x and y parameters passed to that function must not be zero or negative. </remarks> <remarks>Do not use <a href="#CancelSelectTextDraw">CancelSelectTextDraw</a> unconditionally within this callback. This results in an infinite loop. </remarks> <returns> Returning <b><c>1</c></b> in this callback will prevent it being called in other scripts. This should be used to signal that the textdraw on which they clicked was 'found' and no further processing is needed. You should return <b><c>0</c></b> if the textdraw on which they clicked wasn't found, just like in <a href="#OnPlayerCommandText">OnPlayerCommandText</a>.<p/> It is always called first in filterscripts so returning <b><c>1</c></b> there also blocks other scripts from seeing it. </returns>
		</member>
		<member name="M:OnPlayerCommandText" syntax="OnPlayerCommandText(playerid, cmdtext[])">
			<stacksize value="1"/>
			<param name="playerid">
				The ID of the player that entered a command
			</param>
			<param name="cmdtext">
				<paraminfo> [] </paraminfo>
				The command that was entered (including the forward slash)
			</param>
			<summary>This callback is called when a player enters a command into the client chat window. Commands are anything that start with a forward slash, e.g. <c>/help</c>.</summary>   <seealso name="OnPlayerText"/> <seealso name="OnRconCommand"/> <seealso name="SendRconCommand"/> <remarks>This callback can also be called by NPC.</remarks> <returns> Return <b><c>1</c></b> if the command was processed, otherwise <b><c>0</c></b>; If the command was not found both in filterscripts and in gamemode, the player will be received a message: <em>SERVER: Unknown command</em>.<p/> It is always called first in filterscripts so returning <b><c>1</c></b> there blocks other scripts from seeing it. </returns>
		</member>
		<member name="M:OnPlayerConnect" syntax="OnPlayerConnect(playerid)">
			<stacksize value="1"/>
			<param name="playerid">
				The ID of the player that connected
			</param>
			<summary>This callback is called when a player connects to the server.</summary>  <seealso name="OnPlayerDisconnect"/> <seealso name="OnIncomingConnection"/> <seealso name="OnPlayerFinishedDownloading"/> <remarks>This callback can also be called by NPC.</remarks> <returns> <b><c>0</c></b> - Will prevent other filterscripts from receiving this callback.<p/> <b><c>1</c></b> - Indicates that this callback will be passed to the next filterscript.<p/> It is always called first in filterscripts. </returns>
		</member>
		<member name="M:OnPlayerDeath" syntax="OnPlayerDeath(playerid, killerid, reason)">
			<stacksize value="1"/>
			<param name="playerid">
				The ID of the player that died
			</param>
			<param name="killerid">
				The ID of the player that killed the player who died, or <b><c>INVALID_PLAYER_ID</c></b> if there was none
			</param>
			<param name="reason">
				The ID of the <a href="http://wiki.sa-mp.com/wiki/Weapons">reason</a> for the player's death
			</param>
			<summary>This callback is called when a player dies, either by suicide or by being killed by another player.</summary>    <seealso name="OnPlayerSpawn"/> <seealso name="SendDeathMessage"/> <seealso name="SetPlayerHealth"/> <remarks> The reason will return 37 (flame thrower) from any fire sources (e.g. molotov, 18)<p/> The reason will return 51 from any weapon that creates an explosion (e.g. RPG, grenade)<p/> You do not need to check whether killerid is valid before using it in <a href="#SendDeathMessage">SendDeathMessage</a>. <b><c>INVALID_PLAYER_ID</c></b> is a valid killerid ID parameter in that function.<p/> <b>playerid</b> is the only one who can call the callback. (good to know for anti fake death) </remarks> <returns> <b><c>0</c></b> - Will prevent other filterscripts from receiving this callback.<p/> <b><c>1</c></b> - Indicates that this callback will be passed to the next filterscript.<p/> It is always called first in filterscripts. </returns>
		</member>
		<member name="M:OnPlayerDisconnect" syntax="OnPlayerDisconnect(playerid, reason)">
			<stacksize value="1"/>
			<param name="playerid">
				The ID of the player that disconnected
			</param>
			<param name="reason">
				The reason for the disconnection. See table below
			</param>
			<summary>This callback is called when a player disconnects from the server.</summary>   <seealso name="OnPlayerConnect"/> <seealso name="OnIncomingConnection"/> <seealso name="OnPlayerFinishedDownloading"/> <remarks>This callback can also be called by NPC.</remarks> <remarks>Some functions might not work correctly when used in this callback because the player is already disconnected when the callback is called. This means that you can't get unambiguous information from functions like <a href="#GetPlayerIp">GetPlayerIp</a> and <a href="#GetPlayerPos">GetPlayerPos</a>.</remarks> <remarks> <b>Reasons:</b><p/> <ul> <li><b><c>0</c></b> - timeout/Crash - the player's connection was lost. Either their game crashed or their network had a fault.</li> <li><b><c>1</c></b> - quit - the player purposefully quit, either using the <b><c>/quit (/q)</c></b> command or via the pause menu.</li> <li><b><c>2</c></b> - kick/ban - the player was kicked or banned by the server.</li> </ul> </remarks> <returns> <b><c>0</c></b> - Will prevent other filterscripts from receiving this callback.<p/> <b><c>1</c></b> - Indicates that this callback will be passed to the next filterscript.<p/> It is always called first in filterscripts. </returns>
		</member>
		<member name="M:OnPlayerEditAttachedObject" syntax="OnPlayerEditAttachedObject(playerid, response, index, modelid, boneid, fOffsetX, fOffsetY, fOffsetZ, fRotX, fRotY, fRotZ, fScaleX, fScaleY, fScaleZ)">
			<stacksize value="1"/>
			<param name="playerid">
				The ID of the player that ended edition mode
			</param>
			<param name="response">
				<b><c>0</c></b> if they cancelled (ESC) or <b><c>1</c></b> if they clicked the save icon
			</param>
			<param name="index">
				The index of the attached object
			</param>
			<param name="modelid">
				The model of the attached object that was edited
			</param>
			<param name="boneid">
				The bone of the attached object that was edited
			</param>
			<param name="fOffsetX">
				<paraminfo>Float </paraminfo>
				The X offset for the attached object that was edited
			</param>
			<param name="fOffsetY">
				<paraminfo>Float </paraminfo>
				The Y offset for the attached object that was edited
			</param>
			<param name="fOffsetZ">
				<paraminfo>Float </paraminfo>
				The Z offset for the attached object that was edited
			</param>
			<param name="fRotX">
				<paraminfo>Float </paraminfo>
				The X rotation for the attached object that was edited
			</param>
			<param name="fRotY">
				<paraminfo>Float </paraminfo>
				The Y rotation for the attached object that was edited
			</param>
			<param name="fRotZ">
				<paraminfo>Float </paraminfo>
				The Z rotation for the attached object that was edited
			</param>
			<param name="fScaleX">
				<paraminfo>Float </paraminfo>
				The X scale for the attached object that was edited
			</param>
			<param name="fScaleY">
				<paraminfo>Float </paraminfo>
				The Y scale for the attached object that was edited
			</param>
			<param name="fScaleZ">
				<paraminfo>Float </paraminfo>
				The Z scale for the attached object that was edited
			</param>
			<summary>This callback is called when a player ends attached object edition mode.</summary>               <seealso name="EditAttachedObject"/> <seealso name="SetPlayerAttachedObject"/> <remarks>This callback was added in <b>SA-MP 0.3e</b> and will not work in earlier versions!</remarks> <remarks>Editions should be discarded if response was <b><c>0</c></b> (cancelled). This must be done by storing the offsets etc. in an array BEFORE using <a href="#EditAttachedObject">EditAttachedObject</a>.</remarks> <returns> <b><c>1</c></b> - Will prevent other scripts from receiving this callback.<p/> <b><c>0</c></b> - Indicates that this callback will be passed to the next script.<p/> It is always called first in filterscripts. </returns>
		</member>
		<member name="M:OnPlayerEditObject" syntax="OnPlayerEditObject(playerid, playerobject, objectid, response, fX, fY, fZ, fRotX, fRotY, fRotZ)">
			<stacksize value="1"/>
			<param name="playerid">
				The ID of the player that edited an object
			</param>
			<param name="playerobject">
				<b><c>0</c></b> if it is a global object or <b><c>1</c></b> if it is a playerobject
			</param>
			<param name="objectid">
				The ID of the edited object
			</param>
			<param name="response">
				The type of response
			</param>
			<param name="fX">
				<paraminfo>Float </paraminfo>
				The X offset for the object that was edited
			</param>
			<param name="fY">
				<paraminfo>Float </paraminfo>
				The Y offset for the object that was edited
			</param>
			<param name="fZ">
				<paraminfo>Float </paraminfo>
				The Z offset for the object that was edited
			</param>
			<param name="fRotX">
				<paraminfo>Float </paraminfo>
				The X rotation for the object that was edited
			</param>
			<param name="fRotY">
				<paraminfo>Float </paraminfo>
				The Y rotation for the object that was edited
			</param>
			<param name="fRotZ">
				<paraminfo>Float </paraminfo>
				The Z rotation for the object that was edited
			</param>
			<summary>This callback is called when a player finishes editing an object (<a href="#EditObject">EditObject</a>/<a href="#EditPlayerObject">EditPlayerObject</a>).</summary>           <seealso name="EditObject"/> <seealso name="CreateObject"/> <seealso name="DestroyObject"/> <seealso name="MoveObject"/> <remarks>This callback was added in <b>SA-MP 0.3e</b> and will not work in earlier versions!</remarks> <remarks>When using <b><c>EDIT_RESPONSE_UPDATE</c></b> be aware that this callback will not be called when releasing an edit in progress resulting in the last update of <b><c>EDIT_RESPONSE_UPDATE</c></b> being out of sync of the objects current position.</remarks> <returns> <b><c>1</c></b> - Will prevent other scripts from receiving this callback.<p/> <b><c>0</c></b> - Indicates that this callback will be passed to the next script.<p/> It is always called first in filterscripts. </returns>
		</member>
		<member name="M:OnPlayerEnterCheckpoint" syntax="OnPlayerEnterCheckpoint(playerid)">
			<stacksize value="1"/>
			<param name="playerid">
				The player who entered the checkpoint
			</param>
			<summary>This callback is called when a player enters the checkpoint set for that player.</summary>  <seealso name="OnPlayerLeaveCheckpoint"/> <seealso name="OnPlayerEnterRaceCheckpoint"/> <seealso name="OnPlayerLeaveRaceCheckpoint"/> <seealso name="SetPlayerCheckpoint"/> <seealso name="DisablePlayerCheckpoint"/> <seealso name="IsPlayerInCheckpoint"/> <seealso name="SetPlayerRaceCheckpoint"/> <seealso name="DisablePlayerRaceCheckpoint"/> <seealso name="IsPlayerInRaceCheckpoint"/> <remarks>This callback can also be called by NPC.</remarks> <returns> This callback does not handle returns.<p/> It is always called first in filterscripts. </returns>
		</member>
		<member name="M:OnPlayerEnterRaceCheckpoint" syntax="OnPlayerEnterRaceCheckpoint(playerid)">
			<stacksize value="1"/>
			<param name="playerid">
				The ID of the player who entered the race checkpoint
			</param>
			<summary>This callback is called when a player enters a race checkpoint.</summary>  <seealso name="OnPlayerEnterCheckpoint"/> <seealso name="OnPlayerLeaveCheckpoint"/> <seealso name="OnPlayerLeaveRaceCheckpoint"/> <seealso name="SetPlayerCheckpoint"/> <seealso name="DisablePlayerCheckpoint"/> <seealso name="IsPlayerInCheckpoint"/> <seealso name="SetPlayerRaceCheckpoint"/> <seealso name="DisablePlayerRaceCheckpoint"/> <seealso name="IsPlayerInRaceCheckpoint"/> <remarks>This callback can also be called by NPC.</remarks> <returns> This callback does not handle returns.<p/> It is always called first in filterscripts. </returns>
		</member>
		<member name="M:OnPlayerEnterVehicle" syntax="OnPlayerEnterVehicle(playerid, vehicleid, ispassenger)">
			<stacksize value="1"/>
			<param name="playerid">
				ID of the player who attempts to enter a vehicle
			</param>
			<param name="vehicleid">
				ID of the vehicle the player is attempting to enter
			</param>
			<param name="ispassenger">
				<b><c>0</c></b> if entering as driver. <b><c>1</c></b> if entering as passenger
			</param>
			<summary>This callback is called when a player <b><c>starts</c></b> to enter a vehicle, meaning the player is not in vehicle yet at the time this callback is called.</summary>    <seealso name="OnPlayerExitVehicle"/> <seealso name="OnPlayerStateChange"/> <seealso name="PutPlayerInVehicle"/> <seealso name="GetPlayerVehicleSeat"/> <remarks>This callback is called when a player <b>BEGINS</b> to enter a vehicle, not when they HAVE entered it. See <a href="#OnPlayerStateChange">OnPlayerStateChange</a>. </remarks> <remarks>This callback is still called if the player is denied entry to the vehicle (e.g. it is locked or full). </remarks> <returns> This callback does not handle returns.<p/> It is always called first in filterscripts. </returns>
		</member>
		<member name="M:OnPlayerExitVehicle" syntax="OnPlayerExitVehicle(playerid, vehicleid)">
			<stacksize value="1"/>
			<param name="playerid">
				The ID of the player that is exiting a vehicle
			</param>
			<param name="vehicleid">
				The ID of the vehicle the player is exiting
			</param>
			<summary>This callback is called when a player <b>starts</b> to exit a vehicle.</summary>   <seealso name="OnPlayerEnterVehicle"/> <seealso name="OnPlayerStateChange"/> <seealso name="RemovePlayerFromVehicle"/> <seealso name="GetPlayerVehicleSeat"/> <remarks>Not called if the player falls off a bike or is removed from a vehicle by other means such as using <a href="#SetPlayerPos">SetPlayerPos</a>.</remarks> <remarks>You must use <a href="#OnPlayerStateChange">OnPlayerStateChange</a> and check if their old state is <b><c>PLAYER_STATE_DRIVER</c></b> or <b><c>PLAYER_STATE_PASSENGER</c></b> and their new state is <b><c>PLAYER_STATE_ONFOOT</c></b>.</remarks> <returns> This callback does not handle returns.<p/> It is always called first in filterscripts. </returns>
		</member>
		<member name="M:OnPlayerExitedMenu" syntax="OnPlayerExitedMenu(playerid)">
			<stacksize value="1"/>
			<param name="playerid">
				The ID of the player that exited the menu
			</param>
			<summary>Called when a player exits a menu.</summary>  <seealso name="OnPlayerSelectedMenuRow"/> <seealso name="CreateMenu"/> <seealso name="DestroyMenu"/> <returns> This callback does not handle returns.<p/> It is always called first in gamemode. </returns>
		</member>
		<member name="M:OnPlayerFinishedDownloading" syntax="OnPlayerFinishedDownloading(playerid, virtualworld)">
			<stacksize value="1"/>
			<param name="playerid">
				The ID of the player that finished downloading custom models
			</param>
			<param name="virtualworld">
				The ID of the virtual world the player finished downloading custom models for
			</param>
			<summary>This callback is called when a player finishes downloading custom models. For more information on how to add custom models to your server, see <a href="http://forum.sa-mp.com/showthread.php?t=644105">the release thread</a> and <a href="http://forum.sa-mp.com/showthread.php?t=644123">this tutorial</a>.</summary>   <seealso name="OnPlayerConnect"/> <seealso name="OnPlayerDisconnect"/> <seealso name="OnIncomingConnection"/> <remarks>This callback was added in <b>SA-MP 0.3DL</b> and will not work in earlier versions!</remarks> <remarks>This callback is called every time a player changes virtual worlds, even if there are no custom models present in that world.</remarks> <returns>This callback does not handle returns.</returns>
		</member>
		<member name="M:OnPlayerGiveDamage" syntax="OnPlayerGiveDamage(playerid, damagedid, amount, weaponid, bodypart)">
			<stacksize value="1"/>
			<param name="playerid">
				The ID of the player that gave damage
			</param>
			<param name="damagedid">
				The ID of the player that received damage
			</param>
			<param name="amount">
				<paraminfo>Float </paraminfo>
				The amount of health/armour damagedid has lost (combined)
			</param>
			<param name="weaponid">
				The <a href="http://wiki.sa-mp.com/wiki/Weapons">reason</a> that caused the damage
			</param>
			<param name="bodypart">
				The body part that was hit. (NOTE: This parameter was added in <b>0.3z</b>. Leave it out if using an older version!)
			</param>
			<summary>This callback is called when a player gives damage to another player.</summary>      <seealso name="OnPlayerTakeDamage"/> <remarks>This callback was added in <b>SA-MP 0.3d</b> and will not work in earlier versions!</remarks> <remarks> Keep in mind this function can be inaccurate in some cases.<p/> If you want to prevent certain players from damaging eachother, use <a href="#SetPlayerTeam">SetPlayerTeam</a>.<p/> The weaponid will return <b><c>37</c></b> (flame thrower) from any fire sources (e.g. molotov, 18)<p/> The weaponid will return <b><c>51</c></b> from any weapon that creates an explosion (e.g. RPG, grenade)<p/> <b>playerid</b> is the only one who can call the callback.<p/> The amount is always the maximum damage the weaponid can do, even when the health left is less than that maximum damage. So when a player has <b><c>100.0</c></b> health and gets shot with a Desert Eagle which has a damage value of <b><c>46.2</c></b>, it takes 3 shots to kill that player. All 3 shots will show an amount of <b><c>46.2</c></b>, even though when the last shot hits, the player only has <b><c>7.6</c></b> health left. </remarks> <returns> <b><c>1</c></b> - Callback will not be called in other filterscripts.<p/> <b><c>0</c></b> - Allows this callback to be called in other filterscripts.<p/> It is always called first in filterscripts so returning <b><c>1</c></b> there blocks other filterscripts from seeing it. </returns>
		</member>
		<member name="M:OnPlayerGiveDamageActor" syntax="OnPlayerGiveDamageActor(playerid, damaged_actorid, amount, weaponid, bodypart)">
			<stacksize value="1"/>
			<param name="playerid">
				The ID of the player that gave damage
			</param>
			<param name="damaged_actorid">
				The ID of the actor that received damage
			</param>
			<param name="amount">
				<paraminfo>Float </paraminfo>
				The amount of health/armour damaged_actorid has lost
			</param>
			<param name="weaponid">
				The reason that caused the damage
			</param>
			<param name="bodypart">
				The body part that was hit
			</param>
			<summary>This callback is called when a player gives damage to an actor.</summary>      <seealso name="CreateActor"/> <seealso name="SetActorInvulnerable"/> <seealso name="SetActorHealth"/> <seealso name="GetActorHealth"/> <seealso name="IsActorInvulnerable"/> <seealso name="IsValidActor"/> <seealso name="OnActorStreamOut"/> <seealso name="OnPlayerStreamIn"/> <remarks>This callback was added in <b>SA-MP 0.3.7</b> and will not work in earlier versions!</remarks> <remarks>This function does not get called if the actor is set invulnerable (WHICH IS BY DEFAULT). See <a href="#SetActorInvulnerable">SetActorInvulnerable</a>.</remarks> <returns> <b><c>1</c></b> - Callback will not be called in other filterscripts.<p/> <b><c>0</c></b> - Allows this callback to be called in other filterscripts.<p/> It is always called first in filterscripts so returning <b><c>1</c></b> there blocks other filterscripts from seeing it. </returns>
		</member>
		<member name="M:OnPlayerInteriorChange" syntax="OnPlayerInteriorChange(playerid, newinteriorid, oldinteriorid)">
			<stacksize value="1"/>
			<param name="playerid">
				The playerid who changed interior
			</param>
			<param name="newinteriorid">
				The interior the player is now in
			</param>
			<param name="oldinteriorid">
				The interior the player was in before
			</param>
			<summary>Called when a player changes interior. Can be triggered by SetPlayerInterior or when a player enter/exits a building.</summary>    <seealso name="SetPlayerInterior"/> <seealso name="GetPlayerInterior"/> <seealso name="LinkVehicleToInterior"/> <seealso name="OnPlayerStateChange"/> <returns> This callback does not handle returns.<p/> It is always called first in gamemode. </returns>
		</member>
		<member name="M:OnPlayerKeyStateChange" syntax="OnPlayerKeyStateChange(playerid, newkeys, oldkeys)">
			<stacksize value="1"/>
			<param name="playerid">
				The ID of the player that pressed or released a key
			</param>
			<param name="newkeys">
				A map (bitmask) of the keys currently held - see <a href="http://wiki.sa-mp.com/wiki/Keys">here</a>
			</param>
			<param name="oldkeys">
				A map (bitmask) of the keys held prior to the current change - see <a href="http://wiki.sa-mp.com/wiki/Keys">here</a>
			</param>
			<summary>This callback is called when the state of any supported key is changed (pressed/released). Directional keys do not trigger OnPlayerKeyStateChange (up/down/left/right).</summary>    <seealso name="GetPlayerKeys"/> <remarks>This callback can also be called by NPC.</remarks> <remarks> Useful macros:<p/> <code> // HOLDING(keys)<p/> #define HOLDING(%0) ((newkeys &amp; (%0)) == (%0))<p/> <p/> // PRESSED(keys)<p/> #define PRESSED(%0) (((newkeys &amp; (%0)) == (%0)) &amp;&amp; ((oldkeys &amp; (%0)) != (%0)))<p/> <p/> // PRESSING(keyVariable, keys)<p/> #define PRESSING(%0,%1) (%0 &amp; (%1))<p/> <p/> // RELEASED(keys)<p/> #define RELEASED(%0) (((newkeys &amp; (%0)) != (%0)) &amp;&amp; ((oldkeys &amp; (%0)) == (%0)))<p/> </code> </remarks> <returns> This callback does not handle returns.<p/> It is always called first in gamemode. </returns>
		</member>
		<member name="M:OnPlayerLeaveCheckpoint" syntax="OnPlayerLeaveCheckpoint(playerid)">
			<stacksize value="1"/>
			<param name="playerid">
				The ID of the player that left their checkpoint
			</param>
			<summary>This callback is called when a player leaves the checkpoint set for them by <a href="#SetPlayerCheckpoint">SetPlayerCheckpoint</a>. Only one checkpoint can be set at a time.</summary>  <seealso name="OnPlayerEnterCheckpoint"/> <seealso name="OnPlayerEnterRaceCheckpoint"/> <seealso name="OnPlayerLeaveRaceCheckpoint"/> <seealso name="SetPlayerCheckpoint"/> <seealso name="DisablePlayerCheckpoint"/> <seealso name="IsPlayerInCheckpoint"/> <seealso name="SetPlayerRaceCheckpoint"/> <seealso name="DisablePlayerRaceCheckpoint"/> <seealso name="IsPlayerInRaceCheckpoint"/> <remarks>This callback can also be called by NPC.</remarks> <returns> This callback does not handle returns.<p/> It is always called first in filterscripts. </returns>
		</member>
		<member name="M:OnPlayerLeaveRaceCheckpoint" syntax="OnPlayerLeaveRaceCheckpoint(playerid)">
			<stacksize value="1"/>
			<param name="playerid">
				The ID of the player that left the race checkpoint
			</param>
			<summary>This callback is called when a player leaves the race checkpoint.</summary>  <seealso name="OnPlayerEnterCheckpoint"/> <seealso name="OnPlayerLeaveCheckpoint"/> <seealso name="OnPlayerEnterRaceCheckpoint"/> <seealso name="SetPlayerCheckpoint"/> <seealso name="DisablePlayerCheckpoint"/> <seealso name="IsPlayerInCheckpoint"/> <seealso name="SetPlayerRaceCheckpoint"/> <seealso name="DisablePlayerRaceCheckpoint"/> <seealso name="IsPlayerInRaceCheckpoint"/> <remarks>This callback can also be called by NPC.</remarks> <returns> This callback does not handle returns.<p/> It is always called first in filterscripts. </returns>
		</member>
		<member name="M:OnPlayerObjectMoved" syntax="OnPlayerObjectMoved(playerid, objectid)">
			<stacksize value="1"/>
			<param name="playerid">
				The playerid the object is assigned to
			</param>
			<param name="objectid">
				The ID of the player object that was moved
			</param>
			<summary>This callback is called when a player object is moved after <a href="#MovePlayerObject">MovePlayerObject</a> (when it stops moving).</summary>   <seealso name="OnObjectMoved"/> <seealso name="MovePlayerObject"/> <seealso name="IsPlayerObjectMoving"/> <seealso name="StopPlayerObject"/> <remarks>This callback can also be called for NPC.</remarks> <returns> This callback does not handle returns.<p/> It is always called first in filterscripts. </returns>
		</member>
		<member name="M:OnPlayerPickUpPickup" syntax="OnPlayerPickUpPickup(playerid, pickupid)">
			<stacksize value="1"/>
			<param name="playerid">
				The ID of the player that picked up the pickup
			</param>
			<param name="pickupid">
				The ID of the pickup, returned by CreatePickup
			</param>
			<summary>Called when a player picks up a pickup created with <a href="#CreatePickup">CreatePickup</a>.</summary>   <seealso name="CreatePickup"/> <seealso name="DestroyPickup"/> <returns> This callback does not handle returns.<p/> It is always called first in gamemode. </returns>
		</member>
		<member name="M:OnPlayerRequestClass" syntax="OnPlayerRequestClass(playerid, classid)">
			<stacksize value="1"/>
			<param name="playerid">
				The ID of the player that changed class
			</param>
			<param name="classid">
				The ID of the current class being viewed (returned by <a href="#AddPlayerClass">AddPlayerClass</a>)
			</param>
			<summary>Called when a player changes class at class selection (and when class selection first appears).</summary>   <seealso name="OnPlayerRequestSpawn"/> <seealso name="AddPlayerClass"/> <remarks>This callback can also be called by NPC.</remarks> <remarks>This callback is also called when a player presses <b>F4</b>.</remarks> <returns> Returning <b><c>0</c></b> in this callback will prevent the player from spawning. The player can be forced to spawn when <a href="#SpawnPlayer">SpawnPlayer</a> is used.<p/> It is always called first in filterscripts. </returns>
		</member>
		<member name="M:OnPlayerRequestDownload" syntax="OnPlayerRequestDownload(playerid, type, crc)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="type">
			</param>
			<param name="crc">
			</param>
		</member>
		<member name="M:OnPlayerRequestSpawn" syntax="OnPlayerRequestSpawn(playerid)">
			<stacksize value="1"/>
			<param name="playerid">
				The ID of the player that requested to spawn
			</param>
			<summary>Called when a player attempts to spawn via class selection either by pressing SHIFT or clicking the 'Spawn' button.</summary>  <seealso name="OnPlayerSpawn"/> <seealso name="OnPlayerRequestClass"/> <remarks>This callback can also be called by NPC.</remarks> <remarks>To prevent players from spawning with certain classes, the last viewed class must be saved in a variable in <a href="#OnPlayerRequestClass">OnPlayerRequestClass</a>.</remarks> <returns> Returning <b><c>0</c></b> in this callback will prevent the player from spawning.<p/> It is always called first in filterscripts so returning <b><c>0</c></b> there also blocks other scripts from seeing it. </returns>
		</member>
		<member name="M:OnPlayerSelectObject" syntax="OnPlayerSelectObject(playerid, type, objectid, modelid, fX, fY, fZ)">
			<stacksize value="1"/>
			<param name="playerid">
				The ID of the player that selected an object
			</param>
			<param name="type">
				The type of selection
			</param>
			<param name="objectid">
				The ID of the selected object
			</param>
			<param name="modelid">
				The model ID of the selected object
			</param>
			<param name="fX">
				<paraminfo>Float </paraminfo>
				The X position of the selected object
			</param>
			<param name="fY">
				<paraminfo>Float </paraminfo>
				The Y position of the selected object
			</param>
			<param name="fZ">
				<paraminfo>Float </paraminfo>
				The Z position of the selected object
			</param>
			<summary>This callback is called when a player selects an object after <a href="#SelectObject">SelectObject</a> has been used.</summary>        <seealso name="SelectObject"/> <remarks>This function was added in <b>SA-MP 0.3e</b> and will not work in earlier versions!</remarks> <returns> <b><c>1</c></b> - Will prevent other scripts from receiving this callback.<p/> <b><c>0</c></b> - Indicates that this callback will be passed to the next script.<p/> It is always called first in filterscripts. </returns>
		</member>
		<member name="M:OnPlayerSelectedMenuRow" syntax="OnPlayerSelectedMenuRow(playerid, row)">
			<stacksize value="1"/>
			<param name="playerid">
				The ID of the player that selected a menu item
			</param>
			<param name="row">
				The ID of the row that was selected. The first row is ID <b><c>0</c></b>
			</param>
			<summary>This callback is called when a player selects an item from a menu (<a href="#ShowMenuForPlayer">ShowMenuForPlayer</a>).</summary>   <seealso name="OnPlayerExitedMenu"/> <seealso name="OnDialogResponse"/> <seealso name="CreateMenu"/> <seealso name="DestroyMenu"/> <seealso name="AddMenuItem"/> <seealso name="ShowMenuForPlayer"/> <seealso name="HideMenuForPlayer"/> <remarks>The menu ID is not passed to this callback. <a href="#GetPlayerMenu">GetPlayerMenu</a> must be used to determine which menu the player selected an item on.</remarks> <returns> This callback does not handle returns.<p/> It is always called first in gamemode. </returns>
		</member>
		<member name="M:OnPlayerSpawn" syntax="OnPlayerSpawn(playerid)">
			<stacksize value="1"/>
			<param name="playerid">
				The ID of the player that spawned
			</param>
			<summary>This callback is called when a player spawns.(i.e. after caling <a href="#SpawnPlayer">SpawnPlayer</a> function).</summary>  <seealso name="OnPlayerDeath"/> <seealso name="OnVehicleSpawn"/> <seealso name="SpawnPlayer"/> <seealso name="AddPlayerClass"/> <seealso name="SetSpawnInfo"/> <remarks>This callback can also be called by NPC.</remarks> <remarks>The game sometimes deducts $100 from players after spawn.</remarks> <returns> <b><c>0</c></b> - Will prevent other filterscripts from receiving this callback.<p/> <b><c>1</c></b> - Indicates that this callback will be passed to the next filterscript.<p/> It is always called first in filterscripts. </returns>
		</member>
		<member name="M:OnPlayerStateChange" syntax="OnPlayerStateChange(playerid, newstate, oldstate)">
			<stacksize value="1"/>
			<param name="playerid">
				The ID of the player that changed state
			</param>
			<param name="newstate">
				The player's new state
			</param>
			<param name="oldstate">
				The player's previous state
			</param>
			<summary>This callback is called when a player changes state. For example, when a player changes from being the driver of a vehicle to being on-foot.</summary>    <seealso name="OnPlayerInteriorChange"/> <seealso name="GetPlayerState"/> <seealso name="GetPlayerSpecialAction"/> <seealso name="SetPlayerSpecialAction"/> <remarks>This callback can also be called by NPC.</remarks> <remarks> <b>States:</b><p/> <ul> <li><b><c>PLAYER_STATE_NONE</c></b> - empty (while initializing)</li> <li><b><c>PLAYER_STATE_ONFOOT</c></b> - player is on foot</li> <li><b><c>PLAYER_STATE_DRIVER</c></b> - player is the driver of a vehicle</li> <li><b><c>PLAYER_STATE_PASSENGER</c></b> - player is passenger of a vehicle</li> <li><b><c>PLAYER_STATE_WASTED</c></b> - player is dead or on class selection</li> <li><b><c>PLAYER_STATE_SPAWNED</c></b> - player is spawned</li> <li><b><c>PLAYER_STATE_SPECTATING</c></b> - player is spectating</li> <li><b><c>PLAYER_STATE_EXIT_VEHICLE</c></b> - player exits a vehicle</li> <li><b><c>PLAYER_STATE_ENTER_VEHICLE_DRIVER</c></b> - player enters a vehicle as driver</li> <li><b><c>PLAYER_STATE_ENTER_VEHICLE_PASSENGER</c></b> - player enters a vehicle as passenger </li> </ul> </remarks> <returns> This callback does not handle returns.<p/> It is always called first in filterscripts. </returns>
		</member>
		<member name="M:OnPlayerStreamIn" syntax="OnPlayerStreamIn(playerid, forplayerid)">
			<stacksize value="1"/>
			<param name="playerid">
				The ID of the player who has been streamed
			</param>
			<param name="forplayerid">
				The ID of the player that streamed the other player in
			</param>
			<summary>This callback is called when a player is streamed by some other player's client.</summary>   <seealso name="OnPlayerStreamOut"/> <seealso name="OnActorStreamIn"/> <seealso name="OnVehicleStreamIn"/> <remarks>This callback was added in <b>SA-MP 0.3a</b> and will not work in earlier versions!</remarks> <remarks>This callback can also be called by NPC.</remarks> <returns> This callback does not handle returns.<p/> It is always called first in filterscripts. </returns>
		</member>
		<member name="M:OnPlayerStreamOut" syntax="OnPlayerStreamOut(playerid, forplayerid)">
			<stacksize value="1"/>
			<param name="playerid">
				The player who has been destreamed
			</param>
			<param name="forplayerid">
				The player who has destreamed the other player
			</param>
			<summary>This callback is called when a player is streamed out from some other player's client.</summary>   <seealso name="OnPlayerStreamIn"/> <seealso name="OnActorStreamOut"/> <seealso name="OnVehicleStreamOut"/> <remarks>This callback was added in <b>SA-MP 0.3a</b> and will not work in earlier versions!</remarks> <remarks>This callback can also be called by NPC.</remarks> <returns> This callback does not handle returns.<p/> It is always called first in filterscripts. </returns>
		</member>
		<member name="M:OnPlayerTakeDamage" syntax="OnPlayerTakeDamage(playerid, issuerid, amount, weaponid, bodypart)">
			<stacksize value="1"/>
			<param name="playerid">
				The ID of the player that took damage
			</param>
			<param name="issuerid">
				The ID of the player that caused the damage. <b><c>INVALID_PLAYER_ID</c></b> if self-inflicted
			</param>
			<param name="amount">
				<paraminfo>Float </paraminfo>
				The amount of damage the player took (health and armour combined)
			</param>
			<param name="weaponid">
				The ID of the <a href="http://wiki.sa-mp.com/wiki/Weapons">weapon/reason</a> for the damage
			</param>
			<param name="bodypart">
				The body part that was hit. (NOTE: This parameter was added in <b>0.3z</b>. Leave it out if using an older version!)
			</param>
			<summary>This callback is called when a player takes damage.</summary>      <seealso name="OnPlayerGiveDamage"/> <seealso name="OnPlayerWeaponShot"/> <remarks>This callback was added in <b>SA-MP 0.3d</b> and will not work in earlier versions!</remarks> <remarks><a href="#GetPlayerHealth">GetPlayerHealth</a> and <a href="#GetPlayerArmour">GetPlayerArmour</a> will return the old amounts of the player before this callback. </remarks> <remarks> The weaponid will return <b><c>37</c></b> (flame thrower) from any fire sources (e.g. molotov, <b><c>18</c></b>).<p/> The weaponid will return <b><c>51</c></b> from any weapon that creates an explosion (e.g. RPG, grenade)<p/> <b>playerid</b> is the only one who can call the callback.<p/> The amount is always the maximum damage the weaponid can do, even when the health left is less than that maximum damage. So when a player has <b><c>100.0</c></b> health and gets shot with a Desert Eagle which has a damage value of <b><c>46.2</c></b>, it takes 3 shots to kill that player. All 3 shots will show an amount of <b><c>46.2</c></b>, even though when the last shot hits, the player only has <b><c>7.6</c></b> health left. </remarks> <returns> <b><c>1</c></b> - Callback will not be called in other filterscripts.<p/> <b><c>0</c></b> - Allows this callback to be called in other filterscripts.<p/> It is always called first in filterscripts so returning <b><c>1</c></b> there blocks other filterscripts from seeing it. </returns>
		</member>
		<member name="M:OnPlayerText" syntax="OnPlayerText(playerid, text[])">
			<stacksize value="1"/>
			<param name="playerid">
				The ID of the player who typed the text
			</param>
			<param name="text">
				<paraminfo> [] </paraminfo>
				The text the player typed
			</param>
			<summary>Called when a player sends a chat message.</summary>   <seealso name="OnPlayerCommandText"/> <seealso name="SendPlayerMessageToPlayer"/> <seealso name="SendPlayerMessageToAll"/> <remarks>This callback can also be called by NPC.</remarks> <returns> Returning <b><c>0</c></b> in this callback will stop the text from being sent to all players.<p/> It is always called first in filterscripts so returning <b><c>0</c></b> there blocks other scripts from seeing it. </returns>
		</member>
		<member name="M:OnPlayerUpdate" syntax="OnPlayerUpdate(playerid)">
			<stacksize value="1"/>
			<param name="playerid">
				ID of the player sending an update packet
			</param>
			<summary>This callback is called every time a client/player updates the server with their status. It is often used to create custom callbacks for client updates that aren't actively tracked by the server, such as health or armor updates or players switching weapons.</summary>  <remarks>This callback can also be called by NPC.</remarks> <remarks>This callback is called, on average, 30 times per second, per player; only use it when you know what it's meant for (or more importantly what it's NOT meant for). </remarks> <remarks>The frequency with which this callback is called for each player varies, depending on what the player is doing. Driving or shooting will trigger a lot more updates than idling. </remarks> <returns> <b><c>0</c></b> - Update from this player will not be replicated to other clients.<p/> <b><c>1</c></b> - Indicates that this update can be processed normally and sent to other players.<p/> It is always called first in filterscripts. </returns>
		</member>
		<member name="M:OnPlayerWeaponShot" syntax="OnPlayerWeaponShot(playerid, weaponid, hittype, hitid, fX, fY, fZ)">
			<stacksize value="1"/>
			<param name="playerid">
				The ID of the player that shot a weapon
			</param>
			<param name="weaponid">
				The ID of the <a href="http://wiki.sa-mp.com/wiki/Weapons">weapon</a> shot by the player
			</param>
			<param name="hittype">
				The type of thing the shot hit (none, player, vehicle, or (player)object)
			</param>
			<param name="hitid">
				The ID of the player, vehicle or object that was hit
			</param>
			<param name="fX">
				<paraminfo>Float </paraminfo>
				The X coordinate that the shot hit
			</param>
			<param name="fY">
				<paraminfo>Float </paraminfo>
				The Y coordinate that the shot hit
			</param>
			<param name="fZ">
				<paraminfo>Float </paraminfo>
				The Z coordinate that the shot hit
			</param>
			<summary>This callback is called when a player fires a shot from a weapon. Only bullet weapons are supported. Only <b>passenger</b> drive-by is supported (not driver drive-by, and not sea sparrow / hunter shots).</summary>        <seealso name="OnPlayerGiveDamage"/> <seealso name="GetPlayerLastShotVectors"/> <remarks>This callback was added in <b>SA-MP 0.3z</b> and will not work in earlier versions!</remarks> <remarks> <li><b><c>BULLET_HIT_TYPE_NONE(0)</c></b></li> <li><b><c>BULLET_HIT_TYPE_PLAYER(1)</c></b></li> <li><b><c>BULLET_HIT_TYPE_VEHICLE(2)</c></b></li> <li><b><c>BULLET_HIT_TYPE_OBJECT(3)</c></b></li> <li><b><c>BULLET_HIT_TYPE_PLAYER_OBJECT(4)</c></b></li> </remarks> <remarks><b><c>BULLET_HIT_TYPE_PLAYER</c></b> is also called for NPCs. Actors are ignored by this callback and detects as <b><c>BULLET_HIT_TYPE_NONE</c></b>.</remarks> <remarks>This callback is only called when lag compensation is <b>enabled</b>. </remarks> <remarks> If hittype is:<p/> <ul> <li>- <b><c>BULLET_HIT_TYPE_NONE</c></b>: the fX, fY and fZ parameters are normal coordinates, will give 0.0 for coordinates if nothing was hit (e.g. far object that the bullet can't reach);</li> <li>- Others: the fX, fY and fZ are offsets relative to the hitid.</li> </ul> </remarks> <remarks> Isn't called if you fired in vehicle as driver or if you are looking behind with the aim enabled (shooting in air).<p/> It is called as <b><c>BULLET_HIT_TYPE_VEHICLE</c></b> with the correct hitid (the hit player's vehicleid) if you are shooting a player which is in a vehicle. It won't be called as <b><c>BULLET_HIT_TYPE_PLAYER</c></b> at all.<p/> <b>Partially fixed in SA-MP 0.3.7:</b> If fake weapon data is sent by a malicious user, other player clients may freeze or crash. To combat this, check if the reported weaponid can actually fire bullets. </remarks> <remarks> </remarks> <remarks><a href="#GetPlayerLastShotVectors">GetPlayerLastShotVectors</a> can be used in this callback for more detailed bullet vector information.</remarks> <returns> <b><c>0</c></b> - Prevent the bullet from causing damage.<p/> <b><c>1</c></b> - Allow the bullet to cause damage.<p/> It is always called first in filterscripts so returning <b><c>0</c></b> there also blocks other scripts from seeing it. </returns>
		</member>
		<member name="M:OnRconCommand" syntax="OnRconCommand(cmd[])">
			<stacksize value="1"/>
			<param name="cmd">
				<paraminfo> [] </paraminfo>
				A string containing the command that was typed, as well as any passed parameters
			</param>
			<summary>This callback is called when a command is sent through the server console, remote RCON, or via the in-game "/rcon command".</summary>  <seealso name="IsPlayerAdmin"/> <seealso name="OnRconLoginAttempt"/> <remarks>You will need to include this callback in a loaded filterscript for it to work in the gamemode!</remarks> <remarks>"/rcon" is not included in "cmd" when a player types a command. </remarks> <remarks>If you use the <a href="#print">print</a> function here, it will send a message to the player who typed the command in-game as well as the log.</remarks> <remarks>This callback is not called when the player is not logged in as RCON admin. </remarks> <remarks>When the player is not logged in as RCON admin and uses <b>/rcon login</b>, this callback will not be called and <a href="#OnRconLoginAttempt">OnRconLoginAttempt</a> is called instead. However, when the player is logged in as RCON admin, the use of this command will call this callback. </remarks> <returns> <b><c>0</c></b> if the command was not processed, it will be passed to another script or <b><c>1</c></b> if the command was processed, will not be passed to other scripts.<p/> It is always called first in filterscripts so returning <b><c>1</c></b> there blocks gamemode from seeing it. </returns>
		</member>
		<member name="M:OnRconLoginAttempt" syntax="OnRconLoginAttempt(ip[], password[], success)">
			<stacksize value="1"/>
			<param name="ip">
				<paraminfo> [] </paraminfo>
				The IP of the player that tried to log in to RCON
			</param>
			<param name="password">
				<paraminfo> [] </paraminfo>
				The password used to login with
			</param>
			<param name="success">
				<b><c>0</c></b> if the password was incorrect or <b><c>1</c></b> if it was correct
			</param>
			<summary>This callback is called when someone attempts to log in to RCON in-game; successful or not.</summary>    <seealso name="OnRconCommand"/> <seealso name="IsPlayerAdmin"/> <seealso name="SendRconCommand"/> <remarks>This callback was added in <b>SA-MP 0.3a</b> and will not work in earlier versions!</remarks> <remarks>This callback is only called when /rcon login is used in-game. </remarks> <remarks>This callback is only called when the player is not yet logged in. When the player is logged in, <a href="#OnRconCommand">OnRconCommand</a> is called instead.</remarks> <returns> This callback does not handle returns.<p/> It is always called first in filterscripts. </returns>
		</member>
		<member name="M:OnTrailerUpdate" syntax="OnTrailerUpdate(playerid, vehicleid)">
			<stacksize value="1"/>
			<param name="playerid">
				The ID of the player who sent a trailer update
			</param>
			<param name="vehicleid">
				The Trailer being updated
			</param>
			<summary>This callback is called when a player sent a trailer update.</summary>   <seealso name="OnUnoccupiedVehicleUpdate"/> <seealso name="GetVehicleTrailer"/> <seealso name="IsTrailerAttachedToVehicle"/> <seealso name="AttachTrailerToVehicle"/> <seealso name="DetachTrailerFromVehicle"/> <remarks>This callback was added in <b>SA-MP 0.3z R4</b> and will not work in earlier versions!</remarks> <remarks>This callback is called very frequently per second per trailer. You should refrain from implementing intensive calculations or intensive file writing/reading operations in this callback. </remarks> <returns> <b><c>0</c></b> - Cancels any trailer updates from being sent to other players. Update is still sent to the updating player.<p/> <b><c>1</c></b> - Processes the trailer update as normal and synchronizes it between all players.<p/> It is always called first in filterscripts. </returns>
		</member>
		<member name="M:OnUnoccupiedVehicleUpdate" syntax="OnUnoccupiedVehicleUpdate(vehicleid, playerid, passenger_seat, new_x, new_y, new_z, vel_x, vel_y, vel_z)">
			<stacksize value="1"/>
			<param name="vehicleid">
				The ID of the vehicle that's position was updated
			</param>
			<param name="playerid">
				The ID of the player that sent a vehicle position sync update
			</param>
			<param name="passenger_seat">
				The ID of the seat if the player is a passenger. 0=not in vehicle, 1=front passenger, 2=backleft 3=backright 4+ is for coach/bus etc. with many passenger seats
			</param>
			<param name="new_x">
				<paraminfo>Float </paraminfo>
				The new X coordinate of the vehicle. This parameter was added in <b>0.3z</b>. Leave it out if using an earlier version
			</param>
			<param name="new_y">
				<paraminfo>Float </paraminfo>
				The new Y coordinate of the vehicle. This parameter was added in <b>0.3z</b>. Leave it out if using an earlier version
			</param>
			<param name="new_z">
				<paraminfo>Float </paraminfo>
				The new Z coordinate of the vehicle. This parameter was added in <b>0.3z</b>. Leave it out if using an earlier version
			</param>
			<param name="vel_x">
				<paraminfo>Float </paraminfo>
				The new X velocity of the vehicle. This parameter was added in <b>0.3z R4</b>. Leave it out if using an earlier version
			</param>
			<param name="vel_y">
				<paraminfo>Float </paraminfo>
				The new Y velocity of the vehicle. This parameter was added in <b>0.3z R4</b>. Leave it out if using an earlier version
			</param>
			<param name="vel_z">
				<paraminfo>Float </paraminfo>
				The new Z velocity of the vehicle. This parameter was added in <b>0.3z R4</b>. Leave it out if using an earlier version
			</param>
			<summary>This callback is called when a player's client updates/syncs the position of a vehicle they're not driving. This can happen outside of the vehicle or when the player is a passenger of a vehicle that has no driver.</summary>          <seealso name="OnTrailerUpdate"/> <remarks>This callback was added in <b>SA-MP 0.3c R3</b> and will not work in earlier versions!</remarks> <remarks>This callback is called very frequently per second per unoccupied vehicle. You should refrain from implementing intensive calculations or intensive file writing/reading operations in this callback.</remarks> <remarks><a href="#GetVehiclePos">GetVehiclePos</a> will return the old coordinates of the vehicle before this update.</remarks> <returns> Returning <b><c>0</c></b> in this callback will stop the vehicle's position being synced to other players. Update is still sent to the updating player. Useful for combating vehicle teleport hacks.<p/> It is always called first in filterscripts so returning <b><c>0</c></b> there also blocks other scripts from seeing it. </returns>
		</member>
		<member name="M:OnVehicleDamageStatusUpdate" syntax="OnVehicleDamageStatusUpdate(vehicleid, playerid)">
			<stacksize value="1"/>
			<param name="vehicleid">
				The ID of the vehicle that was changed its damage status
			</param>
			<param name="playerid">
				The ID of the player who synced the change in the damage status (who had the car damaged or repaired)
			</param>
			<summary>This callback is called when a vehicle element such as doors, tires, panels, or lights change their damage status.</summary>   <seealso name="GetVehicleDamageStatus"/> <seealso name="UpdateVehicleDamageStatus"/> <remarks>This callback was added in <b>SA-MP 0.3a</b> and will not work in earlier versions!</remarks> <remarks>This does not include vehicle health changes</remarks> <returns> <b><c>1</c></b> - Will prevent other filterscripts from receiving this callback.<p/> <b><c>0</c></b> - Indicates that this callback will be passed to the next filterscript.<p/> It is always called first in filterscripts.<p/> </returns>
		</member>
		<member name="M:OnVehicleDeath" syntax="OnVehicleDeath(vehicleid, killerid)">
			<stacksize value="1"/>
			<param name="vehicleid">
				The ID of the vehicle that was destroyed
			</param>
			<param name="killerid">
				The ID of the player that reported (synced) the vehicle's destruction (name is misleading). Generally the driver or a passenger (if any) or the closest player
			</param>
			<summary>This callback is called when a vehicle is destroyed - either by exploding or becoming submerged in water.</summary>   <seealso name="OnVehicleSpawn"/> <seealso name="SetVehicleHealth"/> <remarks>This callback can also be called by NPC.</remarks> <remarks>This callback will also be called when a vehicle enters water, but the vehicle can be saved from destruction by teleportation or driving out (if only partially submerged). The callback won't be called a second time, and the vehicle may disappear when the driver exits, or after a short time.</remarks> <returns> This callback does not handle returns.<p/> It is always called first in filterscripts. </returns>
		</member>
		<member name="M:OnVehicleMod" syntax="OnVehicleMod(playerid, vehicleid, componentid)">
			<stacksize value="1"/>
			<param name="playerid">
				The ID of the driver of the vehicle
			</param>
			<param name="vehicleid">
				The ID of the vehicle which is modded
			</param>
			<param name="componentid">
				The ID of the component which was added to the vehicle
			</param>
			<summary>This callback is called when a vehicle is modded.</summary>    <seealso name="AddVehicleComponent"/> <seealso name="OnEnterExitModShop"/> <seealso name="OnVehiclePaintjob"/> <seealso name="OnVehicleRespray"/> <remarks>This callback is NOT called by <a href="#AddVehicleComponent">AddVehicleComponent</a>.</remarks> <returns> Return <b><c>0</c></b> to desync the mod (or an invalid mod) from propagating and / or crashing players.<p/> It is always called first in gamemode so returning <b><c>0</c></b> there also blocks other filterscripts from seeing it. </returns>
		</member>
		<member name="M:OnVehiclePaintjob" syntax="OnVehiclePaintjob(playerid, vehicleid, paintjobid)">
			<stacksize value="1"/>
			<param name="playerid">
				The ID of the player that changed the paintjob of their vehicle
			</param>
			<param name="vehicleid">
				The ID of the vehicle that had its paintjob changed
			</param>
			<param name="paintjobid">
				The ID of the new paintjob
			</param>
			<summary>Called when a player previews a vehicle paintjob inside a mod shop. Watch out, this callback is not called when the player buys the paintjob.</summary>    <seealso name="ChangeVehiclePaintjob"/> <seealso name="ChangeVehicleColor"/> <seealso name="OnVehicleRespray"/> <seealso name="OnVehicleMod"/> <remarks>This callback is not called by <a href="#ChangeVehiclePaintjob">ChangeVehiclePaintjob</a>.</remarks> <returns> This callback does not handle returns. Returning <b><c>0</c></b> won't deny the paintjob change.<p/> It is always called first in gamemode so returning <b><c>0</c></b> there blocks other filterscripts from seeing it. </returns>
		</member>
		<member name="M:OnVehicleRespray" syntax="OnVehicleRespray(playerid, vehicleid, color1, color2)">
			<stacksize value="1"/>
			<param name="playerid">
				The ID of the player that is driving the vehicle
			</param>
			<param name="vehicleid">
				The ID of the vehicle that was resprayed
			</param>
			<param name="color1">
				The color that the vehicle's primary color was changed to
			</param>
			<param name="color2">
				The color that the vehicle's secondary color was changed to
			</param>
			<summary>This callback is called when a player exits a mod shop, even if the colors weren't changed. Watch out, the name is ambiguous, Pay 'n' Spray shops don't call this callback.</summary>     <seealso name="ChangeVehicleColor"/> <seealso name="ChangeVehiclePaintjob"/> <seealso name="OnVehiclePaintjob"/> <seealso name="OnVehicleMod"/> <seealso name="OnEnterExitModShop"/> <remarks>Previewing a component inside a mod shop might call this callback.</remarks> <remarks>This callback is not called by <a href="#ChangeVehicleColor">ChangeVehicleColor</a>.</remarks> <returns> Returning <b><c>0</c></b> in this callback will deny the colour change. Returning <b><c>1</c></b> will allow it. This can be used to prevent hackers from changing vehicle colours using cheats.<p/> It is always called first in gamemode so returning <b><c>0</c></b> there also blocks other filterscripts from seeing it. </returns>
		</member>
		<member name="M:OnVehicleSirenStateChange" syntax="OnVehicleSirenStateChange(playerid, vehicleid, newstate)">
			<stacksize value="1"/>
			<param name="playerid">
				The ID of the player that toggled the siren (driver)
			</param>
			<param name="vehicleid">
				The ID of the vehicle of which the siren was toggled for
			</param>
			<param name="newstate">
				<b><c>0</c></b> if siren was turned off, <b><c>1</c></b> if siren was turned on
			</param>
			<summary>This callback is called when a vehicle's siren is toggled.</summary>    <seealso name="GetVehicleParamsSirenState"/> <remarks>This callback was added in <b>SA-MP 0.3.7</b> and will not work in earlier versions!</remarks> <remarks>This callback can also be called by NPC.</remarks> <remarks>This callback is only called when a vehicle's siren is toggled on or off, NOT when the alternate siren is in use (holding horn).</remarks> <returns> <b><c>1</c></b> - Will prevent gamemode from receiving this callback.<p/> <b><c>0</c></b> - Indicates that this callback will be passed to the gamemode.<p/> It is always called first in filterscripts. </returns>
		</member>
		<member name="M:OnVehicleSpawn" syntax="OnVehicleSpawn(vehicleid)">
			<stacksize value="1"/>
			<param name="vehicleid">
				The ID of the vehicle that spawned
			</param>
			<summary>This callback is called when a vehicle <b>re</b>spawns.</summary>  <seealso name="OnVehicleDeath"/> <seealso name="OnPlayerSpawn"/> <seealso name="SetVehicleToRespawn"/> <seealso name="CreateVehicle"/> <returns> <b><c>0</c></b> - Will prevent other filterscripts from receiving this callback.<p/> <b><c>1</c></b> - Indicates that this callback will be passed to the next filterscript.<p/> It is always called first in filterscripts. </returns>
		</member>
		<member name="M:OnVehicleStreamIn" syntax="OnVehicleStreamIn(vehicleid, forplayerid)">
			<stacksize value="1"/>
			<param name="vehicleid">
				The ID of the vehicle that streamed in for the player
			</param>
			<param name="forplayerid">
				The ID of the player who the vehicle streamed in for
			</param>
			<summary>Called when a vehicle is streamed to a player's client.</summary>   <seealso name="OnVehicleStreamOut"/> <seealso name="OnPlayerStreamIn"/> <seealso name="OnPlayerStreamOut"/> <remarks>This callback was added in <b>SA-MP 0.3a</b> and will not work in earlier versions!</remarks> <remarks>This callback can also be called by NPC.</remarks> <returns> This callback does not handle returns.<p/> It is always called first in filterscripts. </returns>
		</member>
		<member name="M:OnVehicleStreamOut" syntax="OnVehicleStreamOut(vehicleid, forplayerid)">
			<stacksize value="1"/>
			<param name="vehicleid">
				The ID of the vehicle that streamed out
			</param>
			<param name="forplayerid">
				The ID of the player who is no longer streaming the vehicle
			</param>
			<summary>This callback is called when a vehicle is streamed out for a player's client (it's so far away that they can't see it).</summary>   <seealso name="OnVehicleStreamIn"/> <seealso name="OnPlayerStreamIn"/> <seealso name="OnPlayerStreamOut"/> <remarks>This callback was added in <b>SA-MP 0.3a</b> and will not work in earlier versions!</remarks> <remarks>This callback can also be called by NPC.</remarks> <returns> This callback does not handle returns.<p/> It is always called first in filterscripts. </returns>
		</member>
		<member name="M:ReverseAxisAngle" syntax="ReverseAxisAngle(src[], dest[])">
			<stacksize value="1"/>
			<referrer name="ReverseRotation"/>
			<dependency name="operator*(Float:,Float:)"/>
			<dependency name="E_AANGLE_ANGLE"/>
			<param name="src">
				<paraminfo> [4] </paraminfo>
				Source axis angle [<ref name="E_AANGLE"/>]
			</param>
			<param name="dest">
				<paraminfo> [4] </paraminfo>
				Dest axis angle [<ref name="E_AANGLE"/>]
			</param>
			<summary>Stores the reverse axis angle in dest</summary> <export>aangle</export>  
		</member>
		<member name="M:ReverseEuler" syntax="ReverseEuler(src[], dest[])">
			<stacksize value="1"/>
			<referrer name="ReverseRotation"/>
			<dependency name="operator-(Float:)"/>
			<dependency name="E_EULER_ALPHA"/>
			<dependency name="E_EULER_BETA"/>
			<dependency name="E_EULER_GAMMA"/>
			<param name="src">
				<paraminfo> [3] </paraminfo>
				Source euler angle [<ref name="E_EULER"/>]
			</param>
			<param name="dest">
				<paraminfo> [3] </paraminfo>
				Dest euler angle [<ref name="E_EULER"/>]
			</param>
			<summary>Stores the reverse euler angle in dest</summary> <export>euler</export>  
		</member>
		<member name="M:ReverseMatrix" syntax="ReverseMatrix(src[], dest[])">
			<stacksize value="1"/>
			<referrer name="ReverseRotation"/>
			<dependency name="E_RMATRIX_00"/>
			<dependency name="E_RMATRIX_01"/>
			<dependency name="E_RMATRIX_02"/>
			<dependency name="E_RMATRIX_10"/>
			<dependency name="E_RMATRIX_11"/>
			<dependency name="E_RMATRIX_12"/>
			<dependency name="E_RMATRIX_20"/>
			<dependency name="E_RMATRIX_21"/>
			<dependency name="E_RMATRIX_22"/>
			<dependency name="m100"/>
			<dependency name="m101"/>
			<dependency name="m102"/>
			<dependency name="m110"/>
			<dependency name="m111"/>
			<dependency name="m112"/>
			<dependency name="m120"/>
			<dependency name="m121"/>
			<dependency name="m122"/>
			<param name="src">
				<paraminfo> [9] </paraminfo>
				Source rotation matrix [<ref name="E_RMATRIX"/>]
			</param>
			<param name="dest">
				<paraminfo> [9] </paraminfo>
				Dest rotation matrix [<ref name="E_RMATRIX"/>]
			</param>
			<summary>Stores the inverse rotation matrix in dest</summary> <export>rmatrix</export>  
		</member>
		<member name="M:ReverseQuat" syntax="ReverseQuat(src[], dest[])">
			<stacksize value="1"/>
			<referrer name="ReverseRotation"/>
			<dependency name="operator*(Float:,Float:)"/>
			<dependency name="E_QUAT_W"/>
			<param name="src">
				<paraminfo> [4] </paraminfo>
				Source quaternion [<ref name="E_QUAT"/>]
			</param>
			<param name="dest">
				<paraminfo> [4] </paraminfo>
				Dest quaternion [<ref name="E_QUAT"/>]
			</param>
			<summary>Stores the conjugated quaternion in dest</summary> <export>quat</export>  
		</member>
		<member name="M:ReverseRotation" syntax="ReverseRotation(src[], dest[])">
			<stacksize value="1"/>
			<dependency name="E_ROTATION_TYPE"/>
			<dependency name="ReverseAxisAngle"/>
			<dependency name="ReverseEuler"/>
			<dependency name="ReverseMatrix"/>
			<dependency name="ReverseQuat"/>
			<dependency name="rtype_axis_angle"/>
			<dependency name="rtype_euler_re_xyz"/>
			<dependency name="rtype_euler_re_xzy"/>
			<dependency name="rtype_euler_re_yxz"/>
			<dependency name="rtype_euler_re_yzx"/>
			<dependency name="rtype_euler_re_zxy"/>
			<dependency name="rtype_euler_re_zyx"/>
			<dependency name="rtype_euler_xyx"/>
			<dependency name="rtype_euler_xyz"/>
			<dependency name="rtype_euler_xzx"/>
			<dependency name="rtype_euler_xzy"/>
			<dependency name="rtype_euler_yxy"/>
			<dependency name="rtype_euler_yxz"/>
			<dependency name="rtype_euler_yzx"/>
			<dependency name="rtype_euler_yzy"/>
			<dependency name="rtype_euler_zxy"/>
			<dependency name="rtype_euler_zxz"/>
			<dependency name="rtype_euler_zyx"/>
			<dependency name="rtype_euler_zyz"/>
			<dependency name="rtype_quaternion"/>
			<dependency name="rtype_rotation_matrix"/>
			<param name="src">
				<paraminfo> [10] </paraminfo>
				Source rotation [<ref name="E_ROTATION"/>]
			</param>
			<param name="dest">
				<paraminfo> [10] </paraminfo>
				Dest rotation [<ref name="E_ROTATION"/>]
			</param>
			<summary>Stores the reverse rotation in dest</summary> <export/>  
		</member>
		<member name="M:RotateAxisAngle" syntax="RotateAxisAngle(aangle[], cX, cY, cZ, pX, pY, pZ, &amp;oX, &amp;oY, &amp;oZ)">
			<stacksize value="10"/>
			<referrer name="RotatePoint"/>
			<dependency name="operator-(Float:,Float:)"/>
			<dependency name="operator+(Float:,Float:)"/>
			<dependency name="operator*(Float:,Float:)"/>
			<dependency name="E_AANGLE_ANGLE"/>
			<dependency name="E_AANGLE_X"/>
			<dependency name="E_AANGLE_Y"/>
			<dependency name="E_AANGLE_Z"/>
			<dependency name="degrees"/>
			<dependency name="floatcos"/>
			<dependency name="floatsin"/>
			<param name="aangle">
				<paraminfo> [4] </paraminfo>
				Axis angle array [<ref name="E_AANGLE"/>]
			</param>
			<param name="cX">
				<paraminfo>Float </paraminfo>
				Rotation origin x
			</param>
			<param name="cY">
				<paraminfo>Float </paraminfo>
				Rotation origin y
			</param>
			<param name="cZ">
				<paraminfo>Float </paraminfo>
				Rotation origin z
			</param>
			<param name="pX">
				<paraminfo>Float </paraminfo>
				Point x
			</param>
			<param name="pY">
				<paraminfo>Float </paraminfo>
				Point y
			</param>
			<param name="pZ">
				<paraminfo>Float </paraminfo>
				Point z
			</param>
			<param name="oX">
				<paraminfo>Float &amp; </paraminfo>
				Output position x
			</param>
			<param name="oY">
				<paraminfo>Float &amp; </paraminfo>
				Output position y
			</param>
			<param name="oZ">
				<paraminfo>Float &amp; </paraminfo>
				Output position z
			</param>
			<summary>Rotates the given point (pX, pY, pZ) and add it to the output position (oX, oY, oZ) using axis angle</summary> <export>aangle</export>           <remarks>Uses Rodrigues' rotation formula</remarks>
		</member>
		<member name="M:RotateMatrix" syntax="RotateMatrix(rmatrix[], cX, cY, cZ, pX, pY, pZ, &amp;oX, &amp;oY, &amp;oZ)">
			<stacksize value="1"/>
			<referrer name="RotatePoint"/>
			<dependency name="operator-(Float:,Float:)"/>
			<dependency name="operator+(Float:,Float:)"/>
			<dependency name="operator*(Float:,Float:)"/>
			<dependency name="m100"/>
			<dependency name="m101"/>
			<dependency name="m102"/>
			<dependency name="m110"/>
			<dependency name="m111"/>
			<dependency name="m112"/>
			<dependency name="m120"/>
			<dependency name="m121"/>
			<dependency name="m122"/>
			<param name="rmatrix">
				<paraminfo> [9] </paraminfo>
				Rotation matrix [<ref name="E_RMATRIX"/>]
			</param>
			<param name="cX">
				<paraminfo>Float </paraminfo>
				Rotation origin x
			</param>
			<param name="cY">
				<paraminfo>Float </paraminfo>
				Rotation origin y
			</param>
			<param name="cZ">
				<paraminfo>Float </paraminfo>
				Rotation origin z
			</param>
			<param name="pX">
				<paraminfo>Float </paraminfo>
				Point x
			</param>
			<param name="pY">
				<paraminfo>Float </paraminfo>
				Point y
			</param>
			<param name="pZ">
				<paraminfo>Float </paraminfo>
				Point z
			</param>
			<param name="oX">
				<paraminfo>Float &amp; </paraminfo>
				Output position x
			</param>
			<param name="oY">
				<paraminfo>Float &amp; </paraminfo>
				Output position y
			</param>
			<param name="oZ">
				<paraminfo>Float &amp; </paraminfo>
				Output position z
			</param>
			<summary>Rotates the given point (pX, pY, pZ) and add it to the output position (oX, oY, oZ) using a rotation matrix</summary> <export>rmatrix</export>          
		</member>
		<member name="M:RotatePoint" syntax="RotatePoint(rotation[], cX, cY, cZ, pX, pY, pZ, &amp;oX, &amp;oY, &amp;oZ)">
			<stacksize value="6"/>
			<dependency name="ConvertRotation"/>
			<dependency name="E_ROTATION_TYPE"/>
			<dependency name="RotateAxisAngle"/>
			<dependency name="RotateMatrix"/>
			<dependency name="RotateQuat"/>
			<dependency name="rtype_axis_angle"/>
			<dependency name="rtype_quaternion"/>
			<dependency name="rtype_rotation_matrix"/>
			<param name="rotation">
				<paraminfo> [10] </paraminfo>
				Rotation array [<ref name="E_ROTATION"/>]
			</param>
			<param name="cX">
				<paraminfo>Float </paraminfo>
				Rotation origin x
			</param>
			<param name="cY">
				<paraminfo>Float </paraminfo>
				Rotation origin y
			</param>
			<param name="cZ">
				<paraminfo>Float </paraminfo>
				Rotation origin z
			</param>
			<param name="pX">
				<paraminfo>Float </paraminfo>
				Point x
			</param>
			<param name="pY">
				<paraminfo>Float </paraminfo>
				Point y
			</param>
			<param name="pZ">
				<paraminfo>Float </paraminfo>
				Point z
			</param>
			<param name="oX">
				<paraminfo>Float &amp; </paraminfo>
				Output position x
			</param>
			<param name="oY">
				<paraminfo>Float &amp; </paraminfo>
				Output position y
			</param>
			<param name="oZ">
				<paraminfo>Float &amp; </paraminfo>
				Output position z
			</param>
			<summary>Rotates the given point (pX, pY, pZ) around origin (cX, cY, cZ) and stores the output position (oX, oY, oZ)</summary> <export/>          
		</member>
		<member name="M:RotateQuat" syntax="RotateQuat(quat[], cX, cY, cZ, pX, pY, pZ, &amp;oX, &amp;oY, &amp;oZ)">
			<stacksize value="3"/>
			<referrer name="RotatePoint"/>
			<dependency name="operator-(Float:,Float:)"/>
			<dependency name="operator+(Float:,Float:)"/>
			<dependency name="operator*(Float:,Float:)"/>
			<dependency name="w1"/>
			<dependency name="x1"/>
			<dependency name="y1"/>
			<dependency name="z1"/>
			<param name="quat">
				<paraminfo> [4] </paraminfo>
				Quaternion array [<ref name="E_QUAT"/>]
			</param>
			<param name="cX">
				<paraminfo>Float </paraminfo>
				Rotation origin x
			</param>
			<param name="cY">
				<paraminfo>Float </paraminfo>
				Rotation origin y
			</param>
			<param name="cZ">
				<paraminfo>Float </paraminfo>
				Rotation origin z
			</param>
			<param name="pX">
				<paraminfo>Float </paraminfo>
				Point x
			</param>
			<param name="pY">
				<paraminfo>Float </paraminfo>
				Point y
			</param>
			<param name="pZ">
				<paraminfo>Float </paraminfo>
				Point z
			</param>
			<param name="oX">
				<paraminfo>Float &amp; </paraminfo>
				Output position x
			</param>
			<param name="oY">
				<paraminfo>Float &amp; </paraminfo>
				Output position y
			</param>
			<param name="oZ">
				<paraminfo>Float &amp; </paraminfo>
				Output position z
			</param>
			<summary>Rotates the given point (pX, pY, pZ) and add it to the output position (oX, oY, oZ) using quaternion</summary> <export>quat</export>          
		</member>
		<member name="M:SetRotation" syntax="SetRotation(rotation[], type, ...)">
			<stacksize value="1"/>
			<dependency name="E_ROTATION_TYPE"/>
			<dependency name="SetRotationFromAxisAngle"/>
			<dependency name="SetRotationFromEuler"/>
			<dependency name="SetRotationFromMatrix"/>
			<dependency name="SetRotationFromQuat"/>
			<dependency name="rtype_axis_angle"/>
			<dependency name="rtype_quaternion"/>
			<dependency name="rtype_rotation_matrix"/>
			<param name="rotation">
				<paraminfo> [10] </paraminfo>
				Rotation array [<ref name="E_ROTATION"/>]
			</param>
			<param name="type">
				<paraminfo>rotationtype </paraminfo>
				Source rotation type
			</param>
			<param name="...">
				<paraminfo>Float </paraminfo>
			</param>
			<summary>Set the rotation array from the given rotation</summary> <export/>   <param name="...">Source rotation</param> <example> SetRotation(rotation, rtype_axis_angle, w, x, y, z);<br/> SetRotation(rotation, rtype_euler_samp, x, y, z);<br/> SetRotation(rotation, rtype_quaternion, w, x, y, z);<br/> SetRotation(rotation, rtype_rotation_matrix, matrix); </example>
		</member>
		<member name="M:SetRotationFromAxisAngle" syntax="SetRotationFromAxisAngle(aangle[], type, &amp;angle, &amp;x, &amp;y, &amp;z)">
			<stacksize value="4"/>
			<referrer name="SetRotation"/>
			<dependency name="E_AANGLE_ANGLE"/>
			<dependency name="E_AANGLE_X"/>
			<dependency name="E_AANGLE_Y"/>
			<dependency name="E_AANGLE_Z"/>
			<dependency name="NormalizeAxisAngle"/>
			<param name="aangle">
				<paraminfo> [4] </paraminfo>
				Axis angle array [<ref name="E_AANGLE"/>]
			</param>
			<param name="type">
				<paraminfo>rotationtype </paraminfo>
				Source rotation type, unused
			</param>
			<param name="angle">
				<paraminfo>Float &amp; </paraminfo>
				Source axis angle rotation
			</param>
			<param name="x">
				<paraminfo>Float &amp; </paraminfo>
				Source axis angle unit vector x
			</param>
			<param name="y">
				<paraminfo>Float &amp; </paraminfo>
				Source axis angle unit vector y
			</param>
			<param name="z">
				<paraminfo>Float &amp; </paraminfo>
				Source axis angle unit vector z
			</param>
			<summary>Set the rotation array from axis angle</summary> <export>aangle</export>      
		</member>
		<member name="M:SetRotationFromEuler" syntax="SetRotationFromEuler(euler[], type, &amp;alpha, &amp;beta, &amp;gamma)">
			<stacksize value="1"/>
			<referrer name="SetRotation"/>
			<dependency name="E_EULER_ALPHA"/>
			<dependency name="E_EULER_BETA"/>
			<dependency name="E_EULER_GAMMA"/>
			<param name="euler">
				<paraminfo> [3] </paraminfo>
				Euler angle array [<ref name="E_EULER"/>]
			</param>
			<param name="type">
				<paraminfo>rotationtype </paraminfo>
				Source rotation type, unused
			</param>
			<param name="alpha">
				<paraminfo>Float &amp; </paraminfo>
				First source euler angle
			</param>
			<param name="beta">
				<paraminfo>Float &amp; </paraminfo>
				Second source euler angle
			</param>
			<param name="gamma">
				<paraminfo>Float &amp; </paraminfo>
				Third source euler angle
			</param>
			<summary>Set the rotation array from euler angle</summary> <export>euler</export>     
		</member>
		<member name="M:SetRotationFromMatrix" syntax="SetRotationFromMatrix(rmatrix[], type, matrix[][])">
			<stacksize value="4"/>
			<referrer name="SetRotation"/>
			<dependency name="E_RMATRIX_00"/>
			<dependency name="E_RMATRIX_01"/>
			<dependency name="E_RMATRIX_02"/>
			<dependency name="E_RMATRIX_10"/>
			<dependency name="E_RMATRIX_11"/>
			<dependency name="E_RMATRIX_12"/>
			<dependency name="E_RMATRIX_20"/>
			<dependency name="E_RMATRIX_21"/>
			<dependency name="E_RMATRIX_22"/>
			<dependency name="NormalizeMatrix"/>
			<param name="rmatrix">
				<paraminfo> [9] </paraminfo>
				Rotation matrix array [<ref name="E_RMATRIX"/>]
			</param>
			<param name="type">
				<paraminfo>rotationtype </paraminfo>
				Source rotation type, unused
			</param>
			<param name="matrix">
				<paraminfo>Float [][] </paraminfo>
				Source matrix[row][coloum]
			</param>
			<summary>Set the rotation array from rotation matrix</summary> <export>rmatrix</export>   
		</member>
		<member name="M:SetRotationFromQuat" syntax="SetRotationFromQuat(quat[], type, &amp;w, &amp;x, &amp;y, &amp;z)">
			<stacksize value="4"/>
			<referrer name="SetRotation"/>
			<dependency name="E_QUAT_W"/>
			<dependency name="E_QUAT_X"/>
			<dependency name="E_QUAT_Y"/>
			<dependency name="E_QUAT_Z"/>
			<dependency name="NormalizeQuat"/>
			<param name="quat">
				<paraminfo> [4] </paraminfo>
				Quaternion array [<ref name="E_QUAT"/>]
			</param>
			<param name="type">
				<paraminfo>rotationtype </paraminfo>
				Source rotation type, unused
			</param>
			<param name="w">
				<paraminfo>Float &amp; </paraminfo>
				Source quaternion scalar part
			</param>
			<param name="x">
				<paraminfo>Float &amp; </paraminfo>
				Source quaternion imaginary part x
			</param>
			<param name="y">
				<paraminfo>Float &amp; </paraminfo>
				Source quaternion imaginary part y
			</param>
			<param name="z">
				<paraminfo>Float &amp; </paraminfo>
				Source quaternion imaginary part z
			</param>
			<summary>Set the rotation array from quaternion</summary> <export>quat</export>      
		</member>
		<member name="M:VectorSize" syntax="VectorSize(x, y, z)">
			<tagname value="Float"/>
			<attribute name="native"/>
			<referrer name="NormalizeMatrix"/>
			<referrer name="NormalizeQuat"/>
			<referrer name="ConvertAxisAngleToQuat"/>
			<referrer name="NormalizeAxisAngle"/>
			<referrer name="ConvertQuatToAxisAngle"/>
			<referrer name="ConvertMatrixToAxisAngle"/>
			<param name="x">
				<paraminfo>Float </paraminfo>
				The vector's magnitude on the X axis
			</param>
			<param name="y">
				<paraminfo>Float </paraminfo>
				The vector's magnitude on the Y axis
			</param>
			<param name="z">
				<paraminfo>Float </paraminfo>
				The vector's magnitude on the Z axis
			</param>
			<summary>Returns the norm (length) of the provided vector.</summary>    <seealso name="GetPlayerDistanceFromPoint"/> <seealso name="GetVehicleDistanceFromPoint"/> <seealso name="floatsqroot"/> <remarks>This function was added in <b>SA-MP 0.3z</b> and will not work in earlier versions!</remarks> <returns>The norm (length) of the provided vector as a float.</returns>
		</member>
		<member name="M:acos" syntax="acos(value)">
			<tagname value="Float"/>
			<attribute name="native"/>
			<referrer name="ConvertQuatToEuler"/>
			<referrer name="ConvertMatrixToEuler"/>
			<referrer name="ConvertQuatToAxisAngle"/>
			<referrer name="ConvertMatrixToAxisAngle"/>
			<param name="value">
				<paraminfo>Float </paraminfo>
				The cosine for which to find the angle for
			</param>
			<summary>Get the inversed value of a cosine in degrees.</summary>  <seealso name="floatcos"/> <returns>The angle in degrees.</returns>
		</member>
		<member name="M:asin" syntax="asin(value)">
			<tagname value="Float"/>
			<attribute name="native"/>
			<referrer name="ConvertQuatToEuler"/>
			<referrer name="ConvertMatrixToEuler"/>
			<param name="value">
				<paraminfo>Float </paraminfo>
				The sine for which to find the angle for
			</param>
			<summary>Get the inversed value of a sine in degrees.</summary>  <seealso name="floatsin"/> <returns>The angle in degrees.</returns>
		</member>
		<member name="M:atan2" syntax="atan2(y, x)">
			<tagname value="Float"/>
			<attribute name="native"/>
			<referrer name="ConvertQuatToEuler"/>
			<referrer name="ConvertMatrixToEuler"/>
			<param name="y">
				<paraminfo>Float </paraminfo>
				y size
			</param>
			<param name="x">
				<paraminfo>Float </paraminfo>
				x size
			</param>
			<summary>Get the multi-valued inversed value of a tangent in degrees.</summary>   <seealso name="atan"/> <seealso name="floattan"/> <returns>The angle in degrees.</returns>
		</member>
		<member name="M:float" syntax="float(value)">
			<tagname value="Float"/>
			<attribute name="native"/>
			<referrer name="operator*(Float:,_:)"/>
			<referrer name="operator/(Float:,_:)"/>
			<referrer name="operator/(_:,Float:)"/>
			<referrer name="operator+(Float:,_:)"/>
			<referrer name="operator-(Float:,_:)"/>
			<referrer name="operator-(_:,Float:)"/>
			<referrer name="operator==(Float:,_:)"/>
			<referrer name="operator!=(Float:,_:)"/>
			<referrer name="operator&gt;(Float:,_:)"/>
			<referrer name="operator&gt;(_:,Float:)"/>
			<referrer name="operator&gt;=(Float:,_:)"/>
			<referrer name="operator&gt;=(_:,Float:)"/>
			<referrer name="operator&lt;(Float:,_:)"/>
			<referrer name="operator&lt;(_:,Float:)"/>
			<referrer name="operator&lt;=(Float:,_:)"/>
			<referrer name="operator&lt;=(_:,Float:)"/>
			<param name="value">
			</param>
		</member>
		<member name="M:floatadd" syntax="floatadd(oper1, oper2)">
			<tagname value="Float"/>
			<attribute name="native"/>
			<referrer name="operator+(Float:,_:)"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
				First float
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
				Second float
			</param>
			<summary>Adds two floats together. This function is redundant as the standard operator (+) does the same thing.</summary>   <seealso name="Floatsub"/> <seealso name="Floatmul"/> <seealso name="Floatdiv"/> <returns>The sum of the two given floats.</returns>
		</member>
		<member name="M:floatcmp" syntax="floatcmp(oper1, oper2)">
			<attribute name="native"/>
			<referrer name="operator==(Float:,Float:)"/>
			<referrer name="operator==(Float:,_:)"/>
			<referrer name="operator!=(Float:,Float:)"/>
			<referrer name="operator!=(Float:,_:)"/>
			<referrer name="operator&gt;(Float:,Float:)"/>
			<referrer name="operator&gt;(Float:,_:)"/>
			<referrer name="operator&gt;(_:,Float:)"/>
			<referrer name="operator&gt;=(Float:,Float:)"/>
			<referrer name="operator&gt;=(Float:,_:)"/>
			<referrer name="operator&gt;=(_:,Float:)"/>
			<referrer name="operator&lt;(Float:,Float:)"/>
			<referrer name="operator&lt;(Float:,_:)"/>
			<referrer name="operator&lt;(_:,Float:)"/>
			<referrer name="operator&lt;=(Float:,Float:)"/>
			<referrer name="operator&lt;=(Float:,_:)"/>
			<referrer name="operator&lt;=(_:,Float:)"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
				The first float value to compare
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
				The second float value to compare
			</param>
			<summary>floatcmp can be used to compare float values to each other, to validate the comparison.</summary>   <returns><b><c>0</c></b> if value does match, <b><c>1</c></b> if the first value is bigger and <b><c>-1</c></b> if the 2nd value is bigger.</returns>
		</member>
		<member name="M:floatcos" syntax="floatcos(value, mode)">
			<tagname value="Float"/>
			<attribute name="native"/>
			<referrer name="ConvertAxisAngleToMatrix"/>
			<referrer name="ConvertEulerToMatrix"/>
			<referrer name="ConvertAxisAngleToQuat"/>
			<referrer name="ConvertEulerToQuat"/>
			<referrer name="RotateAxisAngle"/>
			<param name="value">
				<paraminfo>Float </paraminfo>
				The angle from which to get the cosine
			</param>
			<param name="mode">
				<paraminfo>anglemode </paraminfo>
				The angle mode (see below) to use, depending on the value entered (optional=<b><c>radian</c></b>)
			</param>
			<summary>Get the cosine from a given angle. The input angle may be in radians, degrees or grades.</summary>   <seealso name="floatsin"/> <seealso name="floattan"/> <remarks>GTA/SA-MP use <b>degrees</b> for angles in most circumstances, for example <a href="#GetPlayerFacingAngle">GetPlayerFacingAngle</a>. Therefore, it is most likely you'll want to use the <b>degrees</b> angle mode, not radians. </remarks> <remarks>Also note that angles in GTA are counterclockwise; 270 is East and 90 is West. South is still 180 and North still 0/360. </remarks> <remarks> <b>Angle modes:</b><p/> <ul> <li>radian</li> <li>degrees</li> <li>grades </li> </ul> </remarks> <returns>The cosine of the value entered.</returns>
		</member>
		<member name="M:floatdiv" syntax="floatdiv(dividend, divisor)">
			<tagname value="Float"/>
			<attribute name="native"/>
			<referrer name="operator/(Float:,_:)"/>
			<referrer name="operator/(_:,Float:)"/>
			<param name="dividend">
				<paraminfo>Float </paraminfo>
				First float
			</param>
			<param name="divisor">
				<paraminfo>Float </paraminfo>
				Second float (dividates the first float.)
			</param>
			<summary>Divide one float by another one. Redundant as the division operator (/) does the same thing.</summary>   <seealso name="floatadd"/> <seealso name="floatsub"/> <seealso name="floatmul"/> <returns>The quotient of the two given floats.</returns>
		</member>
		<member name="M:floatmul" syntax="floatmul(oper1, oper2)">
			<tagname value="Float"/>
			<attribute name="native"/>
			<referrer name="operator*(Float:,_:)"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
				First Float
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
				Second Float, the first one gets multiplied with
			</param>
			<summary>Multiplies two floats with each other.</summary>   <seealso name="Floatadd"/> <seealso name="Floatsub"/> <seealso name="Floatdiv"/> <returns>The product of the two given floats.</returns>
		</member>
		<member name="M:floatsin" syntax="floatsin(value, mode)">
			<tagname value="Float"/>
			<attribute name="native"/>
			<referrer name="ConvertAxisAngleToMatrix"/>
			<referrer name="ConvertEulerToMatrix"/>
			<referrer name="ConvertAxisAngleToQuat"/>
			<referrer name="ConvertEulerToQuat"/>
			<referrer name="RotateAxisAngle"/>
			<param name="value">
				<paraminfo>Float </paraminfo>
				The angle from which to get the sine
			</param>
			<param name="mode">
				<paraminfo>anglemode </paraminfo>
				The angle mode (see below) to use, depending on the value entered (optional=<b><c>radian</c></b>)
			</param>
			<summary>Get the sine from a given angle. The input angle may be in radians, degrees or grades.</summary>   <seealso name="floattan"/> <seealso name="floatcos"/> <remarks>GTA/SA-MP use <b>degrees</b> for angles in most circumstances, for example <a href="#GetPlayerFacingAngle">GetPlayerFacingAngle</a>. Therefore, it is most likely you'll want to use the <b>degrees</b> angle mode, not radians. </remarks> <remarks>Also note that angles in GTA are counterclockwise; 270 is East and 90 is West. South is still 180 and North still 0/360. </remarks> <remarks> <b>Angle modes:</b><p/> <ul> <li>radian</li> <li>degrees</li> <li>grades </li> </ul> </remarks> <returns>The sine of the value entered.</returns>
		</member>
		<member name="M:floatsqroot" syntax="floatsqroot(value)">
			<tagname value="Float"/>
			<attribute name="native"/>
			<referrer name="ConvertMatrixToQuat"/>
			<param name="value">
				<paraminfo>Float </paraminfo>
				The value to calculate the square root of
			</param>
			<summary>Calculates the square root of given value.</summary>  <seealso name="floatpower"/> <seealso name="floatlog"/> <remarks>This function raises a "domain" error if the input value is negative. You may use <a href="#floatabs">floatabs</a> to get the absolute (positive) value.</remarks> <returns>The square root of the input value, as a float.</returns>
		</member>
		<member name="M:floatsub" syntax="floatsub(oper1, oper2)">
			<tagname value="Float"/>
			<attribute name="native"/>
			<referrer name="operator-(Float:,_:)"/>
			<referrer name="operator-(_:,Float:)"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
				First Float
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
				Second Float (gets subtracted from the first float.)
			</param>
			<summary>Subtracts one float from another one. Note that this function has no real use, as one can simply use the standard operator (-) instead.</summary>   <seealso name="Floatadd"/> <seealso name="Floatmul"/> <seealso name="Floatdiv"/> <returns>The difference of the two given floats.</returns>
		</member>
		<member name="M:strcat" syntax="strcat(dest[], source[], maxlength)">
			<attribute name="native"/>
			<referrer name="strcopy"/>
			<param name="dest">
				<paraminfo> [] </paraminfo>
				The string to store the two concatenated strings in
			</param>
			<param name="source">
				<paraminfo> [] </paraminfo>
				The source string
			</param>
			<param name="maxlength">
				The maximum length of the destination (optional=<b><c>sizeof dest</c></b>)
			</param>
			<summary>This function concatenates (joins together) two strings into the destination string.</summary>    <seealso name="strcmp"/> <seealso name="strfind"/> <seealso name="strtok"/> <seealso name="strdel"/> <seealso name="strins"/> <seealso name="strlen"/> <seealso name="strmid"/> <seealso name="strpack"/> <seealso name="strval"/> <returns>The length of the new destination string.</returns>
		</member>
		<member name="M:strcmp" syntax="strcmp(string1[], string2[], ignorecase, length)">
			<attribute name="native"/>
			<referrer name="strequal"/>
			<param name="string1">
				<paraminfo> [] </paraminfo>
				The first string to compare
			</param>
			<param name="string2">
				<paraminfo> [] </paraminfo>
				The second string to compare
			</param>
			<param name="ignorecase">
				<paraminfo>bool </paraminfo>
				When set to true, the case doesn't matter - HeLLo is the same as Hello. When false, they're not the same (optional=<b><c>0</c></b>)
			</param>
			<param name="length">
				When this length is set, the first x chars will be compared - doing "Hello" and "Hell No" with a length of 4 will say it's the same string (optional=<b><c>cellmax</c></b>)
			</param>
			<summary>Compares two strings to see if they are the same.</summary>     <seealso name="strfind"/> <seealso name="strtok"/> <seealso name="strdel"/> <seealso name="strins"/> <seealso name="strlen"/> <seealso name="strmid"/> <seealso name="strpack"/> <seealso name="strval"/> <seealso name="strcat"/> <seealso name="strequal"/> <remarks>This function returns <b><c>0</c></b> if either string is empty. Check for null strings with <c>isnull()</c>. If you do not, for example, people can login to anyone's account by simply entering a blank password. </remarks> <remarks> <code> #if !defined isnull<p/> &#9;#define isnull(%1) ((!(%1[0])) || (((%1[0]) == '\1') &amp;&amp; (!(%1[1]))))<p/> #endif </code> </remarks> <remarks>If you compare strings from a text file, you should take in to account the 'carriage return' and 'new line' special characters (\r \n), as they are included, when using fread.</remarks> <returns> <b><c>0</c></b> if strings match each other on given length;.<p/> <b><c>1</c></b> or <b><c>-1</c></b> if some character do not match: <c>string1[i] - string2[i]</c>.<p/> <b>difference in number of characters</b> if one string matches only part of another string. </returns>
		</member>
		<member name="M:strcopy" syntax="strcopy(dest[], source[], maxlength)">
			<stacksize value="5"/>
			<dependency name="EOS"/>
			<dependency name="strcat"/>
			<param name="dest">
				<paraminfo> [] </paraminfo>
				The string to copy the source string into
			</param>
			<param name="source">
				<paraminfo> [] </paraminfo>
				The source string
			</param>
			<param name="maxlength">
				The maximum length of the destination (optional=<b><c>sizeof dest</c></b>)
			</param>
			<summary>Copies a string into the destination string.</summary>    <seealso name="strcat"/> <returns>The length of the new destination string.</returns>
		</member>
		<member name="M:strequal" syntax="strequal(string1[], string2[], ignorecase, length)">
			<tagname value="bool"/>
			<stacksize value="6"/>
			<dependency name="strcmp"/>
			<param name="string1">
				<paraminfo> [] </paraminfo>
				The first string to compare
			</param>
			<param name="string2">
				<paraminfo> [] </paraminfo>
				The second string to compare
			</param>
			<param name="ignorecase">
				<paraminfo>bool </paraminfo>
				When set to true, the case doesn't matter - HeLLo is the same as Hello. When false, they're not the same (optional=<b><c>0</c></b>)
			</param>
			<param name="length">
				When this length is set, the first x chars will be compared - doing "Hello" and "Hell No" with a length of 4 will say it's the same string (optional=<b><c>cellmax</c></b>)
			</param>
			<summary>Compares two strings to see if they are the same.</summary>     <seealso name="strcmp"/> <remarks>This is a conveniece function that depends on <a href=#strcmp>strcmp</a>.</remarks> <returns><b><c>true</c></b> if the strings match each other on given length, <b><c>false</c></b> otherwise.</returns> </returns>
		</member>

	</members>
</doc>
